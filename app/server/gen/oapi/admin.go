// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package oapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	JWTAuthScopes = "JWTAuth.Scopes"
)

// AdditionalFileInfoInput defines model for AdditionalFileInfoInput.
type AdditionalFileInfoInput struct {
	Content *string `json:"content,omitempty"`
	Name    *string `json:"name,omitempty"`
	Path    *string `json:"path,omitempty"`
}

// AdditionalFileInfoWithID defines model for AdditionalFileInfoWithID.
type AdditionalFileInfoWithID struct {
	Content *string `json:"content,omitempty"`
	Id      *uint   `json:"id,omitempty"`
	Name    *string `json:"name,omitempty"`
	Path    *string `json:"path,omitempty"`
}

// CertDownload defines model for CertDownload.
type CertDownload struct {
	Certificate             *string `json:"certificate,omitempty"`
	Csr                     *string `json:"csr,omitempty"`
	IntermediateCertificate *string `json:"intermediate_certificate,omitempty"`
	PrivateKey              *string `json:"private_key,omitempty"`
}

// CertInfoInput defines model for CertInfoInput.
type CertInfoInput struct {
	Domains  *[]string `json:"domains,omitempty"`
	Name     *string   `json:"name,omitempty"`
	Provider *string   `json:"provider,omitempty"`
}

// CertInfoWithID defines model for CertInfoWithID.
type CertInfoWithID struct {
	Domains *[]string `json:"domains,omitempty"`

	// ExpiresAt unix second
	ExpiresAt *Timestamp `json:"expires_at,omitempty"`
	Id        *uint      `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Provider  *string    `json:"provider,omitempty"`
}

// ErrorMessage defines model for ErrorMessage.
type ErrorMessage struct {
	Message *string `json:"message,omitempty"`
}

// InstanceInfoFull defines model for InstanceInfoFull.
type InstanceInfoFull struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectWithID `json:"additional_file_ids,omitempty"`

	// AdditionalFiles List of additional files
	AdditionalFiles *[]AdditionalFileInfoWithID `json:"additional_files,omitempty"`
	IsManualMode    *bool                       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectWithID `json:"site_ids,omitempty"`

	// Sites List of sites
	Sites *[]SiteInfoWithID `json:"sites,omitempty"`
}

// InstanceInfoInput defines model for InstanceInfoInput.
type InstanceInfoInput struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectWithID `json:"additional_file_ids,omitempty"`
	IsManualMode      *bool           `json:"is_manual_mode,omitempty"`
	Name              *string         `json:"name,omitempty"`
	PreConfig         *string         `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectWithID `json:"site_ids,omitempty"`
}

// InstanceInfoWithID defines model for InstanceInfoWithID.
type InstanceInfoWithID struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectWithID `json:"additional_file_ids,omitempty"`

	// AdditionalFiles List of additional files
	AdditionalFiles *[]AdditionalFileInfoWithID `json:"additional_files,omitempty"`
	Id              *uint                       `json:"id,omitempty"`
	IsManualMode    *bool                       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectWithID `json:"site_ids,omitempty"`

	// Sites List of sites
	Sites *[]SiteInfoWithID `json:"sites,omitempty"`
}

// InstanceInfoWithToken defines model for InstanceInfoWithToken.
type InstanceInfoWithToken struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectWithID `json:"additional_file_ids,omitempty"`

	// AdditionalFiles List of additional files
	AdditionalFiles *[]AdditionalFileInfoWithID `json:"additional_files,omitempty"`
	Id              *uint                       `json:"id,omitempty"`
	IsManualMode    *bool                       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectWithID `json:"site_ids,omitempty"`

	// Sites List of sites
	Sites *[]SiteInfoWithID `json:"sites,omitempty"`
	Token *string           `json:"token,omitempty"`
}

// SiteInfoFull defines model for SiteInfoFull.
type SiteInfoFull struct {
	Cert *CertInfoWithID `json:"cert,omitempty"`

	// CertId Cert ID for this site
	CertId   *uint               `json:"cert_id,omitempty"`
	Name     *string             `json:"name,omitempty"`
	Origins  *[]string           `json:"origins,omitempty"`
	Template *TemplateInfoWithID `json:"template,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// SiteInfoInput defines model for SiteInfoInput.
type SiteInfoInput struct {
	// CertId Cert ID for this site
	CertId  *uint     `json:"cert_id,omitempty"`
	Name    *string   `json:"name,omitempty"`
	Origins *[]string `json:"origins,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// SiteInfoWithID defines model for SiteInfoWithID.
type SiteInfoWithID struct {
	Cert *CertInfoWithID `json:"cert,omitempty"`

	// CertId Cert ID for this site
	CertId   *uint               `json:"cert_id,omitempty"`
	Id       *uint               `json:"id,omitempty"`
	Name     *string             `json:"name,omitempty"`
	Origins  *[]string           `json:"origins,omitempty"`
	Template *TemplateInfoWithID `json:"template,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// TemplateInfoInput defines model for TemplateInfoInput.
type TemplateInfoInput struct {
	Content     *string   `json:"content,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Variables   *[]string `json:"variables,omitempty"`
}

// TemplateInfoWithID defines model for TemplateInfoWithID.
type TemplateInfoWithID struct {
	Content     *string   `json:"content,omitempty"`
	Description *string   `json:"description,omitempty"`
	Id          *uint     `json:"id,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Variables   *[]string `json:"variables,omitempty"`
}

// UserInfoCreate defines model for UserInfoCreate.
type UserInfoCreate struct {
	IsAdmin  *bool   `json:"is_admin,omitempty"`
	Name     *string `json:"name,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserInfoFull defines model for UserInfoFull.
type UserInfoFull struct {
	IsAdmin  *bool   `json:"is_admin,omitempty"`
	Name     *string `json:"name,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserInfoInput defines model for UserInfoInput.
type UserInfoInput struct {
	Name *string `json:"name,omitempty"`
}

// UserInfoWithID defines model for UserInfoWithID.
type UserInfoWithID struct {
	Id       *ObjectWithID `json:"id,omitempty"`
	IsAdmin  *bool         `json:"is_admin,omitempty"`
	Name     *string       `json:"name,omitempty"`
	Username *string       `json:"username,omitempty"`
}

// ObjectWithID defines model for objectWithID.
type ObjectWithID struct {
	Id *uint `json:"id,omitempty"`
}

// PageMax defines model for page_max.
type PageMax = int64

// Timestamp unix second
type Timestamp = int64

// Id defines model for id.
type Id = uint

// Limit defines model for limit.
type Limit = uint

// Page defines model for page.
type Page = int64

// AdditionalFileListParams defines parameters for AdditionalFileList.
type AdditionalFileListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// AuthLoginJSONBody defines parameters for AuthLogin.
type AuthLoginJSONBody struct {
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// CertListParams defines parameters for CertList.
type CertListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// InstanceListParams defines parameters for InstanceList.
type InstanceListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// SiteListParams defines parameters for SiteList.
type SiteListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// TemplateListParams defines parameters for TemplateList.
type TemplateListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// UserListParams defines parameters for UserList.
type UserListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// UserPasswordUpdateJSONBody defines parameters for UserPasswordUpdate.
type UserPasswordUpdateJSONBody struct {
	Password *string `json:"password,omitempty"`
}

// UserRoleUpdateJSONBody defines parameters for UserRoleUpdate.
type UserRoleUpdateJSONBody struct {
	IsAdmin *bool `json:"is_admin,omitempty"`
}

// UserUsernameUpdateJSONBody defines parameters for UserUsernameUpdate.
type UserUsernameUpdateJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// AdditionalFileCreateJSONRequestBody defines body for AdditionalFileCreate for application/json ContentType.
type AdditionalFileCreateJSONRequestBody = AdditionalFileInfoInput

// AdditionalFileInfoUpdateJSONRequestBody defines body for AdditionalFileInfoUpdate for application/json ContentType.
type AdditionalFileInfoUpdateJSONRequestBody = AdditionalFileInfoInput

// AuthLoginJSONRequestBody defines body for AuthLogin for application/json ContentType.
type AuthLoginJSONRequestBody AuthLoginJSONBody

// CertCreateJSONRequestBody defines body for CertCreate for application/json ContentType.
type CertCreateJSONRequestBody = CertInfoInput

// CertInfoUpdateJSONRequestBody defines body for CertInfoUpdate for application/json ContentType.
type CertInfoUpdateJSONRequestBody = CertInfoInput

// InstanceCreateJSONRequestBody defines body for InstanceCreate for application/json ContentType.
type InstanceCreateJSONRequestBody = InstanceInfoInput

// InstanceInfoUpdateJSONRequestBody defines body for InstanceInfoUpdate for application/json ContentType.
type InstanceInfoUpdateJSONRequestBody = InstanceInfoInput

// SiteCreateJSONRequestBody defines body for SiteCreate for application/json ContentType.
type SiteCreateJSONRequestBody = SiteInfoInput

// SiteInfoUpdateJSONRequestBody defines body for SiteInfoUpdate for application/json ContentType.
type SiteInfoUpdateJSONRequestBody = SiteInfoInput

// TemplateCreateJSONRequestBody defines body for TemplateCreate for application/json ContentType.
type TemplateCreateJSONRequestBody = TemplateInfoInput

// TemplateInfoUpdateJSONRequestBody defines body for TemplateInfoUpdate for application/json ContentType.
type TemplateInfoUpdateJSONRequestBody = TemplateInfoInput

// UserCreateJSONRequestBody defines body for UserCreate for application/json ContentType.
type UserCreateJSONRequestBody = UserInfoCreate

// UserInfoUpdateJSONRequestBody defines body for UserInfoUpdate for application/json ContentType.
type UserInfoUpdateJSONRequestBody = UserInfoInput

// UserPasswordUpdateJSONRequestBody defines body for UserPasswordUpdate for application/json ContentType.
type UserPasswordUpdateJSONRequestBody UserPasswordUpdateJSONBody

// UserRoleUpdateJSONRequestBody defines body for UserRoleUpdate for application/json ContentType.
type UserRoleUpdateJSONRequestBody UserRoleUpdateJSONBody

// UserUsernameUpdateJSONRequestBody defines body for UserUsernameUpdate for application/json ContentType.
type UserUsernameUpdateJSONRequestBody UserUsernameUpdateJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// create additional-file
	// (POST /additional-file/create)
	AdditionalFileCreate(ctx echo.Context) error
	// delete additional-file
	// (DELETE /additional-file/delete/{id})
	AdditionalFileDelete(ctx echo.Context, id Id) error
	// get additional-file info
	// (GET /additional-file/info/{id})
	AdditionalFileInfoGet(ctx echo.Context, id Id) error
	// update additional-file info
	// (PATCH /additional-file/info/{id})
	AdditionalFileInfoUpdate(ctx echo.Context, id Id) error
	// get additional-file list
	// (GET /additional-file/list)
	AdditionalFileList(ctx echo.Context, params AdditionalFileListParams) error
	// login
	// (POST /auth/login)
	AuthLogin(ctx echo.Context) error
	// create cert
	// (POST /cert/create)
	CertCreate(ctx echo.Context) error
	// delete cert
	// (DELETE /cert/delete/{id})
	CertDelete(ctx echo.Context, id Id) error
	// download cert pair
	// (GET /cert/download/{id})
	CertInfoGet(ctx echo.Context, id Id) error
	// get cert info
	// (GET /cert/info/{id})
	CertInfoGet(ctx echo.Context, id Id) error
	// update cert info
	// (PATCH /cert/info/{id})
	CertInfoUpdate(ctx echo.Context, id Id) error
	// get cert list
	// (GET /cert/list)
	CertList(ctx echo.Context, params CertListParams) error
	// renew cert
	// (POST /cert/renew/{id})
	CertRenew(ctx echo.Context, id Id) error
	// health check
	// (GET /health)
	HealthCheck(ctx echo.Context) error
	// create instance
	// (POST /instance/create)
	InstanceCreate(ctx echo.Context) error
	// delete instance
	// (DELETE /instance/delete/{id})
	InstanceDelete(ctx echo.Context, id Id) error
	// get instance info
	// (GET /instance/info/{id})
	InstanceInfoGet(ctx echo.Context, id Id) error
	// update instance info
	// (PATCH /instance/info/{id})
	InstanceInfoUpdate(ctx echo.Context, id Id) error
	// get instance list
	// (GET /instance/list)
	InstanceList(ctx echo.Context, params InstanceListParams) error
	// regenerate
	// (POST /instance/rotate-token/{id})
	InstanceRotateToken(ctx echo.Context, id Id) error
	// create site
	// (POST /site/create)
	SiteCreate(ctx echo.Context) error
	// delete site
	// (DELETE /site/delete/{id})
	SiteDelete(ctx echo.Context, id Id) error
	// get site info
	// (GET /site/info/{id})
	SiteInfoGet(ctx echo.Context, id Id) error
	// update site info
	// (PATCH /site/info/{id})
	SiteInfoUpdate(ctx echo.Context, id Id) error
	// get site list
	// (GET /site/list)
	SiteList(ctx echo.Context, params SiteListParams) error
	// create template
	// (POST /template/create)
	TemplateCreate(ctx echo.Context) error
	// delete template
	// (DELETE /template/delete/{id})
	TemplateDelete(ctx echo.Context, id Id) error
	// get template info
	// (GET /template/info/{id})
	TemplateInfoGet(ctx echo.Context, id Id) error
	// update template info
	// (PATCH /template/info/{id})
	TemplateInfoUpdate(ctx echo.Context, id Id) error
	// get template list
	// (GET /template/list)
	TemplateList(ctx echo.Context, params TemplateListParams) error
	// create new user
	// (POST /user/create)
	UserCreate(ctx echo.Context) error
	// delete user
	// (DELETE /user/delete/{id})
	UserDelete(ctx echo.Context, id Id) error
	// get user info
	// (GET /user/info/{id})
	UserInfoGet(ctx echo.Context, id Id) error
	// update user info
	// (PATCH /user/info/{id})
	UserInfoUpdate(ctx echo.Context, id Id) error
	// get user list
	// (GET /user/list)
	UserList(ctx echo.Context, params UserListParams) error
	// update password
	// (PUT /user/password/{id})
	UserPasswordUpdate(ctx echo.Context, id Id) error
	// update role
	// (PUT /user/role/{id})
	UserRoleUpdate(ctx echo.Context, id Id) error
	// update username
	// (PUT /user/username/{id})
	UserUsernameUpdate(ctx echo.Context, id Id) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AdditionalFileCreate converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileCreate(ctx)
	return err
}

// AdditionalFileDelete converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileDelete(ctx, id)
	return err
}

// AdditionalFileInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileInfoGet(ctx, id)
	return err
}

// AdditionalFileInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileInfoUpdate(ctx, id)
	return err
}

// AdditionalFileList converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdditionalFileListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileList(ctx, params)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AuthLogin(ctx)
	return err
}

// CertCreate converts echo context to params.
func (w *ServerInterfaceWrapper) CertCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertCreate(ctx)
	return err
}

// CertDelete converts echo context to params.
func (w *ServerInterfaceWrapper) CertDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertDelete(ctx, id)
	return err
}

// CertInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoGet(ctx, id)
	return err
}

// CertInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoGet(ctx, id)
	return err
}

// CertInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoUpdate(ctx, id)
	return err
}

// CertList converts echo context to params.
func (w *ServerInterfaceWrapper) CertList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CertListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertList(ctx, params)
	return err
}

// CertRenew converts echo context to params.
func (w *ServerInterfaceWrapper) CertRenew(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertRenew(ctx, id)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// InstanceCreate converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceCreate(ctx)
	return err
}

// InstanceDelete converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceDelete(ctx, id)
	return err
}

// InstanceInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceInfoGet(ctx, id)
	return err
}

// InstanceInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceInfoUpdate(ctx, id)
	return err
}

// InstanceList converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params InstanceListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceList(ctx, params)
	return err
}

// InstanceRotateToken converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceRotateToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceRotateToken(ctx, id)
	return err
}

// SiteCreate converts echo context to params.
func (w *ServerInterfaceWrapper) SiteCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteCreate(ctx)
	return err
}

// SiteDelete converts echo context to params.
func (w *ServerInterfaceWrapper) SiteDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteDelete(ctx, id)
	return err
}

// SiteInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) SiteInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteInfoGet(ctx, id)
	return err
}

// SiteInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SiteInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteInfoUpdate(ctx, id)
	return err
}

// SiteList converts echo context to params.
func (w *ServerInterfaceWrapper) SiteList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params SiteListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteList(ctx, params)
	return err
}

// TemplateCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateCreate(ctx)
	return err
}

// TemplateDelete converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateDelete(ctx, id)
	return err
}

// TemplateInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateInfoGet(ctx, id)
	return err
}

// TemplateInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateInfoUpdate(ctx, id)
	return err
}

// TemplateList converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params TemplateListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateList(ctx, params)
	return err
}

// UserCreate converts echo context to params.
func (w *ServerInterfaceWrapper) UserCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserCreate(ctx)
	return err
}

// UserDelete converts echo context to params.
func (w *ServerInterfaceWrapper) UserDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserDelete(ctx, id)
	return err
}

// UserInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoGet(ctx, id)
	return err
}

// UserInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoUpdate(ctx, id)
	return err
}

// UserList converts echo context to params.
func (w *ServerInterfaceWrapper) UserList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserList(ctx, params)
	return err
}

// UserPasswordUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserPasswordUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserPasswordUpdate(ctx, id)
	return err
}

// UserRoleUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserRoleUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserRoleUpdate(ctx, id)
	return err
}

// UserUsernameUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserUsernameUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserUsernameUpdate(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/additional-file/create", wrapper.AdditionalFileCreate)
	router.DELETE(baseURL+"/additional-file/delete/:id", wrapper.AdditionalFileDelete)
	router.GET(baseURL+"/additional-file/info/:id", wrapper.AdditionalFileInfoGet)
	router.PATCH(baseURL+"/additional-file/info/:id", wrapper.AdditionalFileInfoUpdate)
	router.GET(baseURL+"/additional-file/list", wrapper.AdditionalFileList)
	router.POST(baseURL+"/auth/login", wrapper.AuthLogin)
	router.POST(baseURL+"/cert/create", wrapper.CertCreate)
	router.DELETE(baseURL+"/cert/delete/:id", wrapper.CertDelete)
	router.GET(baseURL+"/cert/download/:id", wrapper.CertInfoGet)
	router.GET(baseURL+"/cert/info/:id", wrapper.CertInfoGet)
	router.PATCH(baseURL+"/cert/info/:id", wrapper.CertInfoUpdate)
	router.GET(baseURL+"/cert/list", wrapper.CertList)
	router.POST(baseURL+"/cert/renew/:id", wrapper.CertRenew)
	router.GET(baseURL+"/health", wrapper.HealthCheck)
	router.POST(baseURL+"/instance/create", wrapper.InstanceCreate)
	router.DELETE(baseURL+"/instance/delete/:id", wrapper.InstanceDelete)
	router.GET(baseURL+"/instance/info/:id", wrapper.InstanceInfoGet)
	router.PATCH(baseURL+"/instance/info/:id", wrapper.InstanceInfoUpdate)
	router.GET(baseURL+"/instance/list", wrapper.InstanceList)
	router.POST(baseURL+"/instance/rotate-token/:id", wrapper.InstanceRotateToken)
	router.POST(baseURL+"/site/create", wrapper.SiteCreate)
	router.DELETE(baseURL+"/site/delete/:id", wrapper.SiteDelete)
	router.GET(baseURL+"/site/info/:id", wrapper.SiteInfoGet)
	router.PATCH(baseURL+"/site/info/:id", wrapper.SiteInfoUpdate)
	router.GET(baseURL+"/site/list", wrapper.SiteList)
	router.POST(baseURL+"/template/create", wrapper.TemplateCreate)
	router.DELETE(baseURL+"/template/delete/:id", wrapper.TemplateDelete)
	router.GET(baseURL+"/template/info/:id", wrapper.TemplateInfoGet)
	router.PATCH(baseURL+"/template/info/:id", wrapper.TemplateInfoUpdate)
	router.GET(baseURL+"/template/list", wrapper.TemplateList)
	router.POST(baseURL+"/user/create", wrapper.UserCreate)
	router.DELETE(baseURL+"/user/delete/:id", wrapper.UserDelete)
	router.GET(baseURL+"/user/info/:id", wrapper.UserInfoGet)
	router.PATCH(baseURL+"/user/info/:id", wrapper.UserInfoUpdate)
	router.GET(baseURL+"/user/list", wrapper.UserList)
	router.PUT(baseURL+"/user/password/:id", wrapper.UserPasswordUpdate)
	router.PUT(baseURL+"/user/role/:id", wrapper.UserRoleUpdate)
	router.PUT(baseURL+"/user/username/:id", wrapper.UserUsernameUpdate)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
