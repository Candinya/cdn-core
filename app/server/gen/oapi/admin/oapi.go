// Package admin provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package admin

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JWTAuthScopes = "JWTAuth.Scopes"
)

// AdditionalFileInfoFile defines model for AdditionalFileInfoFile.
type AdditionalFileInfoFile struct {
	Content *openapi_types.File `json:"content,omitempty"`
}

// AdditionalFileInfoInput defines model for AdditionalFileInfoInput.
type AdditionalFileInfoInput struct {
	Filename *string `json:"filename,omitempty"`
	Name     *string `json:"name,omitempty"`
}

// AdditionalFileInfoWithID defines model for AdditionalFileInfoWithID.
type AdditionalFileInfoWithID struct {
	Filename *string   `json:"filename,omitempty"`
	Id       *ObjectID `json:"id,omitempty"`
	Name     *string   `json:"name,omitempty"`
}

// AdditionalFileListResponse defines model for AdditionalFileListResponse.
type AdditionalFileListResponse struct {
	Limit   *int                        `json:"limit,omitempty"`
	List    *[]AdditionalFileInfoWithID `json:"list,omitempty"`
	PageMax *PageMax                    `json:"page_max,omitempty"`
}

// CertInfoInput defines model for CertInfoInput.
type CertInfoInput struct {
	Certificate             *string   `json:"certificate,omitempty"`
	Csr                     *string   `json:"csr,omitempty"`
	Domains                 *[]string `json:"domains,omitempty"`
	IntermediateCertificate *string   `json:"intermediate_certificate,omitempty"`
	Name                    *string   `json:"name,omitempty"`
	PrivateKey              *string   `json:"private_key,omitempty"`
	Provider                *string   `json:"provider,omitempty"`
}

// CertInfoWithID defines model for CertInfoWithID.
type CertInfoWithID struct {
	Certificate *string   `json:"certificate,omitempty"`
	Csr         *string   `json:"csr,omitempty"`
	Domains     *[]string `json:"domains,omitempty"`

	// ExpiresAt unix second
	ExpiresAt               *Timestamp `json:"expires_at,omitempty"`
	Id                      *ObjectID  `json:"id,omitempty"`
	IntermediateCertificate *string    `json:"intermediate_certificate,omitempty"`
	Name                    *string    `json:"name,omitempty"`
	PrivateKey              *string    `json:"private_key,omitempty"`
	Provider                *string    `json:"provider,omitempty"`
}

// CertListResponse defines model for CertListResponse.
type CertListResponse struct {
	Limit   *int              `json:"limit,omitempty"`
	List    *[]CertInfoWithID `json:"list,omitempty"`
	PageMax *PageMax          `json:"page_max,omitempty"`
}

// ErrorMessage defines model for ErrorMessage.
type ErrorMessage struct {
	Message *string `json:"message,omitempty"`
}

// InstanceInfoFull defines model for InstanceInfoFull.
type InstanceInfoFull struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
}

// InstanceInfoInput defines model for InstanceInfoInput.
type InstanceInfoInput struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`
	Name              *string     `json:"name,omitempty"`
	PreConfig         *string     `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
}

// InstanceInfoWithID defines model for InstanceInfoWithID.
type InstanceInfoWithID struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	Id                *ObjectID   `json:"id,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
}

// InstanceInfoWithToken defines model for InstanceInfoWithToken.
type InstanceInfoWithToken struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	Id                *ObjectID   `json:"id,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
	Token   *string     `json:"token,omitempty"`
}

// InstanceListResponse defines model for InstanceListResponse.
type InstanceListResponse struct {
	Limit   *int                  `json:"limit,omitempty"`
	List    *[]InstanceInfoWithID `json:"list,omitempty"`
	PageMax *PageMax              `json:"page_max,omitempty"`
}

// LoginToken defines model for LoginToken.
type LoginToken struct {
	// Token JWT Token
	Token *string `json:"token,omitempty"`
}

// SiteInfoInput defines model for SiteInfoInput.
type SiteInfoInput struct {
	// CertId Cert ID for this site
	CertId *uint   `json:"cert_id,omitempty"`
	Name   *string `json:"name,omitempty"`
	Origin *string `json:"origin,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// SiteInfoWithID defines model for SiteInfoWithID.
type SiteInfoWithID struct {
	// CertId Cert ID for this site
	CertId *uint     `json:"cert_id,omitempty"`
	Id     *ObjectID `json:"id,omitempty"`
	Name   *string   `json:"name,omitempty"`
	Origin *string   `json:"origin,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// SiteListResponse defines model for SiteListResponse.
type SiteListResponse struct {
	Limit   *int              `json:"limit,omitempty"`
	List    *[]SiteInfoWithID `json:"list,omitempty"`
	PageMax *PageMax          `json:"page_max,omitempty"`
}

// TemplateInfoInput defines model for TemplateInfoInput.
type TemplateInfoInput struct {
	Content     *string   `json:"content,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Variables   *[]string `json:"variables,omitempty"`
}

// TemplateInfoWithID defines model for TemplateInfoWithID.
type TemplateInfoWithID struct {
	Content     *string   `json:"content,omitempty"`
	Description *string   `json:"description,omitempty"`
	Id          *ObjectID `json:"id,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Variables   *[]string `json:"variables,omitempty"`
}

// TemplateListResponse defines model for TemplateListResponse.
type TemplateListResponse struct {
	Limit   *int                  `json:"limit,omitempty"`
	List    *[]TemplateInfoWithID `json:"list,omitempty"`
	PageMax *PageMax              `json:"page_max,omitempty"`
}

// UserInfoCreate defines model for UserInfoCreate.
type UserInfoCreate struct {
	IsAdmin  *bool   `json:"is_admin,omitempty"`
	Name     *string `json:"name,omitempty"`
	Password string  `json:"password"`
	Username string  `json:"username"`
}

// UserInfoFull defines model for UserInfoFull.
type UserInfoFull struct {
	IsAdmin  *bool   `json:"is_admin,omitempty"`
	Name     *string `json:"name,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserInfoInput defines model for UserInfoInput.
type UserInfoInput struct {
	Name *string `json:"name,omitempty"`
}

// UserInfoWithID defines model for UserInfoWithID.
type UserInfoWithID struct {
	Id       *ObjectID `json:"id,omitempty"`
	IsAdmin  *bool     `json:"is_admin,omitempty"`
	Name     *string   `json:"name,omitempty"`
	Username *string   `json:"username,omitempty"`
}

// UserListResponse defines model for UserListResponse.
type UserListResponse struct {
	Limit   *int              `json:"limit,omitempty"`
	List    *[]UserInfoWithID `json:"list,omitempty"`
	PageMax *PageMax          `json:"page_max,omitempty"`
}

// ObjectID defines model for objectID.
type ObjectID = uint

// ObjectWithID defines model for objectWithID.
type ObjectWithID struct {
	Id *ObjectID `json:"id,omitempty"`
}

// PageMax defines model for page_max.
type PageMax = int64

// Timestamp unix second
type Timestamp = int64

// Id defines model for id.
type Id = uint

// Limit defines model for limit.
type Limit = uint

// Page defines model for page.
type Page = uint

// AdditionalFileCreateMultipartBody defines parameters for AdditionalFileCreate.
type AdditionalFileCreateMultipartBody struct {
	Content  *openapi_types.File `json:"content,omitempty"`
	Filename *string             `json:"filename,omitempty"`
	Name     *string             `json:"name,omitempty"`
}

// AdditionalFileListParams defines parameters for AdditionalFileList.
type AdditionalFileListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// AdditionalFileReplaceMultipartBody defines parameters for AdditionalFileReplace.
type AdditionalFileReplaceMultipartBody = AdditionalFileInfoFile

// AuthLoginJSONBody defines parameters for AuthLogin.
type AuthLoginJSONBody struct {
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// CertListParams defines parameters for CertList.
type CertListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// InstanceListParams defines parameters for InstanceList.
type InstanceListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// SiteListParams defines parameters for SiteList.
type SiteListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// TemplateListParams defines parameters for TemplateList.
type TemplateListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// UserListParams defines parameters for UserList.
type UserListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// UserPasswordUpdateJSONBody defines parameters for UserPasswordUpdate.
type UserPasswordUpdateJSONBody struct {
	Password *string `json:"password,omitempty"`
}

// UserRoleUpdateJSONBody defines parameters for UserRoleUpdate.
type UserRoleUpdateJSONBody struct {
	IsAdmin *bool `json:"is_admin,omitempty"`
}

// UserUsernameUpdateJSONBody defines parameters for UserUsernameUpdate.
type UserUsernameUpdateJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// AdditionalFileCreateMultipartRequestBody defines body for AdditionalFileCreate for multipart/form-data ContentType.
type AdditionalFileCreateMultipartRequestBody AdditionalFileCreateMultipartBody

// AdditionalFileInfoUpdateJSONRequestBody defines body for AdditionalFileInfoUpdate for application/json ContentType.
type AdditionalFileInfoUpdateJSONRequestBody = AdditionalFileInfoInput

// AdditionalFileReplaceMultipartRequestBody defines body for AdditionalFileReplace for multipart/form-data ContentType.
type AdditionalFileReplaceMultipartRequestBody = AdditionalFileReplaceMultipartBody

// AuthLoginJSONRequestBody defines body for AuthLogin for application/json ContentType.
type AuthLoginJSONRequestBody AuthLoginJSONBody

// CertCreateJSONRequestBody defines body for CertCreate for application/json ContentType.
type CertCreateJSONRequestBody = CertInfoInput

// CertInfoUpdateJSONRequestBody defines body for CertInfoUpdate for application/json ContentType.
type CertInfoUpdateJSONRequestBody = CertInfoInput

// InstanceCreateJSONRequestBody defines body for InstanceCreate for application/json ContentType.
type InstanceCreateJSONRequestBody = InstanceInfoInput

// InstanceInfoUpdateJSONRequestBody defines body for InstanceInfoUpdate for application/json ContentType.
type InstanceInfoUpdateJSONRequestBody = InstanceInfoInput

// SiteCreateJSONRequestBody defines body for SiteCreate for application/json ContentType.
type SiteCreateJSONRequestBody = SiteInfoInput

// SiteInfoUpdateJSONRequestBody defines body for SiteInfoUpdate for application/json ContentType.
type SiteInfoUpdateJSONRequestBody = SiteInfoInput

// TemplateCreateJSONRequestBody defines body for TemplateCreate for application/json ContentType.
type TemplateCreateJSONRequestBody = TemplateInfoInput

// TemplateInfoUpdateJSONRequestBody defines body for TemplateInfoUpdate for application/json ContentType.
type TemplateInfoUpdateJSONRequestBody = TemplateInfoInput

// UserCreateJSONRequestBody defines body for UserCreate for application/json ContentType.
type UserCreateJSONRequestBody = UserInfoCreate

// UserInfoUpdateJSONRequestBody defines body for UserInfoUpdate for application/json ContentType.
type UserInfoUpdateJSONRequestBody = UserInfoInput

// UserPasswordUpdateJSONRequestBody defines body for UserPasswordUpdate for application/json ContentType.
type UserPasswordUpdateJSONRequestBody UserPasswordUpdateJSONBody

// UserRoleUpdateJSONRequestBody defines body for UserRoleUpdate for application/json ContentType.
type UserRoleUpdateJSONRequestBody UserRoleUpdateJSONBody

// UserUsernameUpdateJSONRequestBody defines body for UserUsernameUpdate for application/json ContentType.
type UserUsernameUpdateJSONRequestBody UserUsernameUpdateJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// create additional-file
	// (POST /additional-file/create)
	AdditionalFileCreate(ctx echo.Context) error
	// delete additional-file
	// (DELETE /additional-file/delete/{id})
	AdditionalFileDelete(ctx echo.Context, id Id) error
	// download additional-file
	// (GET /additional-file/download/{id})
	AdditionalFileDownload(ctx echo.Context, id Id) error
	// get additional-file info
	// (GET /additional-file/info/{id})
	AdditionalFileInfoGet(ctx echo.Context, id Id) error
	// update additional-file info
	// (PATCH /additional-file/info/{id})
	AdditionalFileInfoUpdate(ctx echo.Context, id Id) error
	// get additional-file list
	// (GET /additional-file/list)
	AdditionalFileList(ctx echo.Context, params AdditionalFileListParams) error
	// replace additional-file
	// (POST /additional-file/replace/{id})
	AdditionalFileReplace(ctx echo.Context, id Id) error
	// login
	// (POST /auth/login)
	AuthLogin(ctx echo.Context) error
	// create cert
	// (POST /cert/create)
	CertCreate(ctx echo.Context) error
	// delete cert
	// (DELETE /cert/delete/{id})
	CertDelete(ctx echo.Context, id Id) error
	// get cert info
	// (GET /cert/info/{id})
	CertInfoGet(ctx echo.Context, id Id) error
	// update cert info
	// (PATCH /cert/info/{id})
	CertInfoUpdate(ctx echo.Context, id Id) error
	// get cert list
	// (GET /cert/list)
	CertList(ctx echo.Context, params CertListParams) error
	// renew cert
	// (POST /cert/renew/{id})
	CertRenew(ctx echo.Context, id Id) error
	// health check
	// (GET /health)
	HealthCheck(ctx echo.Context) error
	// create instance
	// (POST /instance/create)
	InstanceCreate(ctx echo.Context) error
	// delete instance
	// (DELETE /instance/delete/{id})
	InstanceDelete(ctx echo.Context, id Id) error
	// get instance info
	// (GET /instance/info/{id})
	InstanceInfoGet(ctx echo.Context, id Id) error
	// update instance info
	// (PATCH /instance/info/{id})
	InstanceInfoUpdate(ctx echo.Context, id Id) error
	// get instance list
	// (GET /instance/list)
	InstanceList(ctx echo.Context, params InstanceListParams) error
	// regenerate instance token
	// (POST /instance/rotate-token/{id})
	InstanceRotateToken(ctx echo.Context, id Id) error
	// create site
	// (POST /site/create)
	SiteCreate(ctx echo.Context) error
	// delete site
	// (DELETE /site/delete/{id})
	SiteDelete(ctx echo.Context, id Id) error
	// get site info
	// (GET /site/info/{id})
	SiteInfoGet(ctx echo.Context, id Id) error
	// update site info
	// (PATCH /site/info/{id})
	SiteInfoUpdate(ctx echo.Context, id Id) error
	// get site list
	// (GET /site/list)
	SiteList(ctx echo.Context, params SiteListParams) error
	// create template
	// (POST /template/create)
	TemplateCreate(ctx echo.Context) error
	// delete template
	// (DELETE /template/delete/{id})
	TemplateDelete(ctx echo.Context, id Id) error
	// get template info
	// (GET /template/info/{id})
	TemplateInfoGet(ctx echo.Context, id Id) error
	// update template info
	// (PATCH /template/info/{id})
	TemplateInfoUpdate(ctx echo.Context, id Id) error
	// get template list
	// (GET /template/list)
	TemplateList(ctx echo.Context, params TemplateListParams) error
	// create new user
	// (POST /user/create)
	UserCreate(ctx echo.Context) error
	// delete user
	// (DELETE /user/delete/{id})
	UserDelete(ctx echo.Context, id Id) error
	// get self info
	// (GET /user/info)
	UserInfoGetSelf(ctx echo.Context) error
	// get user info
	// (GET /user/info/{id})
	UserInfoGet(ctx echo.Context, id Id) error
	// update user info
	// (PATCH /user/info/{id})
	UserInfoUpdate(ctx echo.Context, id Id) error
	// get user list
	// (GET /user/list)
	UserList(ctx echo.Context, params UserListParams) error
	// update password
	// (PUT /user/password/{id})
	UserPasswordUpdate(ctx echo.Context, id Id) error
	// update role
	// (PUT /user/role/{id})
	UserRoleUpdate(ctx echo.Context, id Id) error
	// update username
	// (PUT /user/username/{id})
	UserUsernameUpdate(ctx echo.Context, id Id) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AdditionalFileCreate converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileCreate(ctx)
	return err
}

// AdditionalFileDelete converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileDelete(ctx, id)
	return err
}

// AdditionalFileDownload converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileDownload(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileDownload(ctx, id)
	return err
}

// AdditionalFileInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileInfoGet(ctx, id)
	return err
}

// AdditionalFileInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileInfoUpdate(ctx, id)
	return err
}

// AdditionalFileList converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdditionalFileListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileList(ctx, params)
	return err
}

// AdditionalFileReplace converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileReplace(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileReplace(ctx, id)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AuthLogin(ctx)
	return err
}

// CertCreate converts echo context to params.
func (w *ServerInterfaceWrapper) CertCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertCreate(ctx)
	return err
}

// CertDelete converts echo context to params.
func (w *ServerInterfaceWrapper) CertDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertDelete(ctx, id)
	return err
}

// CertInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoGet(ctx, id)
	return err
}

// CertInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoUpdate(ctx, id)
	return err
}

// CertList converts echo context to params.
func (w *ServerInterfaceWrapper) CertList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CertListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertList(ctx, params)
	return err
}

// CertRenew converts echo context to params.
func (w *ServerInterfaceWrapper) CertRenew(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertRenew(ctx, id)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// InstanceCreate converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceCreate(ctx)
	return err
}

// InstanceDelete converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceDelete(ctx, id)
	return err
}

// InstanceInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceInfoGet(ctx, id)
	return err
}

// InstanceInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceInfoUpdate(ctx, id)
	return err
}

// InstanceList converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params InstanceListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceList(ctx, params)
	return err
}

// InstanceRotateToken converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceRotateToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceRotateToken(ctx, id)
	return err
}

// SiteCreate converts echo context to params.
func (w *ServerInterfaceWrapper) SiteCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteCreate(ctx)
	return err
}

// SiteDelete converts echo context to params.
func (w *ServerInterfaceWrapper) SiteDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteDelete(ctx, id)
	return err
}

// SiteInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) SiteInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteInfoGet(ctx, id)
	return err
}

// SiteInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SiteInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteInfoUpdate(ctx, id)
	return err
}

// SiteList converts echo context to params.
func (w *ServerInterfaceWrapper) SiteList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SiteListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteList(ctx, params)
	return err
}

// TemplateCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateCreate(ctx)
	return err
}

// TemplateDelete converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateDelete(ctx, id)
	return err
}

// TemplateInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateInfoGet(ctx, id)
	return err
}

// TemplateInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateInfoUpdate(ctx, id)
	return err
}

// TemplateList converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TemplateListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateList(ctx, params)
	return err
}

// UserCreate converts echo context to params.
func (w *ServerInterfaceWrapper) UserCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserCreate(ctx)
	return err
}

// UserDelete converts echo context to params.
func (w *ServerInterfaceWrapper) UserDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserDelete(ctx, id)
	return err
}

// UserInfoGetSelf converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoGetSelf(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoGetSelf(ctx)
	return err
}

// UserInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoGet(ctx, id)
	return err
}

// UserInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoUpdate(ctx, id)
	return err
}

// UserList converts echo context to params.
func (w *ServerInterfaceWrapper) UserList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserList(ctx, params)
	return err
}

// UserPasswordUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserPasswordUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserPasswordUpdate(ctx, id)
	return err
}

// UserRoleUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserRoleUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserRoleUpdate(ctx, id)
	return err
}

// UserUsernameUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserUsernameUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserUsernameUpdate(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/additional-file/create", wrapper.AdditionalFileCreate)
	router.DELETE(baseURL+"/additional-file/delete/:id", wrapper.AdditionalFileDelete)
	router.GET(baseURL+"/additional-file/download/:id", wrapper.AdditionalFileDownload)
	router.GET(baseURL+"/additional-file/info/:id", wrapper.AdditionalFileInfoGet)
	router.PATCH(baseURL+"/additional-file/info/:id", wrapper.AdditionalFileInfoUpdate)
	router.GET(baseURL+"/additional-file/list", wrapper.AdditionalFileList)
	router.POST(baseURL+"/additional-file/replace/:id", wrapper.AdditionalFileReplace)
	router.POST(baseURL+"/auth/login", wrapper.AuthLogin)
	router.POST(baseURL+"/cert/create", wrapper.CertCreate)
	router.DELETE(baseURL+"/cert/delete/:id", wrapper.CertDelete)
	router.GET(baseURL+"/cert/info/:id", wrapper.CertInfoGet)
	router.PATCH(baseURL+"/cert/info/:id", wrapper.CertInfoUpdate)
	router.GET(baseURL+"/cert/list", wrapper.CertList)
	router.POST(baseURL+"/cert/renew/:id", wrapper.CertRenew)
	router.GET(baseURL+"/health", wrapper.HealthCheck)
	router.POST(baseURL+"/instance/create", wrapper.InstanceCreate)
	router.DELETE(baseURL+"/instance/delete/:id", wrapper.InstanceDelete)
	router.GET(baseURL+"/instance/info/:id", wrapper.InstanceInfoGet)
	router.PATCH(baseURL+"/instance/info/:id", wrapper.InstanceInfoUpdate)
	router.GET(baseURL+"/instance/list", wrapper.InstanceList)
	router.POST(baseURL+"/instance/rotate-token/:id", wrapper.InstanceRotateToken)
	router.POST(baseURL+"/site/create", wrapper.SiteCreate)
	router.DELETE(baseURL+"/site/delete/:id", wrapper.SiteDelete)
	router.GET(baseURL+"/site/info/:id", wrapper.SiteInfoGet)
	router.PATCH(baseURL+"/site/info/:id", wrapper.SiteInfoUpdate)
	router.GET(baseURL+"/site/list", wrapper.SiteList)
	router.POST(baseURL+"/template/create", wrapper.TemplateCreate)
	router.DELETE(baseURL+"/template/delete/:id", wrapper.TemplateDelete)
	router.GET(baseURL+"/template/info/:id", wrapper.TemplateInfoGet)
	router.PATCH(baseURL+"/template/info/:id", wrapper.TemplateInfoUpdate)
	router.GET(baseURL+"/template/list", wrapper.TemplateList)
	router.POST(baseURL+"/user/create", wrapper.UserCreate)
	router.DELETE(baseURL+"/user/delete/:id", wrapper.UserDelete)
	router.GET(baseURL+"/user/info", wrapper.UserInfoGetSelf)
	router.GET(baseURL+"/user/info/:id", wrapper.UserInfoGet)
	router.PATCH(baseURL+"/user/info/:id", wrapper.UserInfoUpdate)
	router.GET(baseURL+"/user/list", wrapper.UserList)
	router.PUT(baseURL+"/user/password/:id", wrapper.UserPasswordUpdate)
	router.PUT(baseURL+"/user/role/:id", wrapper.UserRoleUpdate)
	router.PUT(baseURL+"/user/username/:id", wrapper.UserUsernameUpdate)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"4phMU5fcPez+HwAA//9Bm+DAZm8AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
