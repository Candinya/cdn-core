// Package admin provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package admin

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JWTAuthScopes = "JWTAuth.Scopes"
)

// AdditionalFileInfoFile defines model for AdditionalFileInfoFile.
type AdditionalFileInfoFile struct {
	Content *openapi_types.File `json:"content,omitempty"`
}

// AdditionalFileInfoInput defines model for AdditionalFileInfoInput.
type AdditionalFileInfoInput struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// AdditionalFileInfoWithID defines model for AdditionalFileInfoWithID.
type AdditionalFileInfoWithID struct {
	Id   *ObjectID `json:"id,omitempty"`
	Name *string   `json:"name,omitempty"`
	Path *string   `json:"path,omitempty"`
}

// AdditionalFileListResponse defines model for AdditionalFileListResponse.
type AdditionalFileListResponse struct {
	Limit   *int                        `json:"limit,omitempty"`
	List    *[]AdditionalFileInfoWithID `json:"list,omitempty"`
	PageMax *PageMax                    `json:"page_max,omitempty"`
}

// CertDownload defines model for CertDownload.
type CertDownload struct {
	Certificate             *string `json:"certificate,omitempty"`
	Csr                     *string `json:"csr,omitempty"`
	IntermediateCertificate *string `json:"intermediate_certificate,omitempty"`
	PrivateKey              *string `json:"private_key,omitempty"`
}

// CertInfoInput defines model for CertInfoInput.
type CertInfoInput struct {
	Domains  *[]string `json:"domains,omitempty"`
	Name     *string   `json:"name,omitempty"`
	Provider *string   `json:"provider,omitempty"`
}

// CertInfoWithID defines model for CertInfoWithID.
type CertInfoWithID struct {
	Domains *[]string `json:"domains,omitempty"`

	// ExpiresAt unix second
	ExpiresAt *Timestamp `json:"expires_at,omitempty"`
	Id        *ObjectID  `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Provider  *string    `json:"provider,omitempty"`
}

// CertListResponse defines model for CertListResponse.
type CertListResponse struct {
	Limit   *int              `json:"limit,omitempty"`
	List    *[]CertInfoWithID `json:"list,omitempty"`
	PageMax *PageMax          `json:"page_max,omitempty"`
}

// ErrorMessage defines model for ErrorMessage.
type ErrorMessage struct {
	Message *string `json:"message,omitempty"`
}

// InstanceInfoFull defines model for InstanceInfoFull.
type InstanceInfoFull struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
}

// InstanceInfoInput defines model for InstanceInfoInput.
type InstanceInfoInput struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`
	Name              *string     `json:"name,omitempty"`
	PreConfig         *string     `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
}

// InstanceInfoWithID defines model for InstanceInfoWithID.
type InstanceInfoWithID struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	Id                *ObjectID   `json:"id,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
}

// InstanceInfoWithToken defines model for InstanceInfoWithToken.
type InstanceInfoWithToken struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	Id                *ObjectID   `json:"id,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
	Token   *string     `json:"token,omitempty"`
}

// InstanceListResponse defines model for InstanceListResponse.
type InstanceListResponse struct {
	Limit   *int                  `json:"limit,omitempty"`
	List    *[]InstanceInfoWithID `json:"list,omitempty"`
	PageMax *PageMax              `json:"page_max,omitempty"`
}

// LoginToken defines model for LoginToken.
type LoginToken struct {
	// Token JWT Token
	Token *string `json:"token,omitempty"`
}

// SiteInfoInput defines model for SiteInfoInput.
type SiteInfoInput struct {
	// CertId Cert ID for this site
	CertId *uint   `json:"cert_id,omitempty"`
	Name   *string `json:"name,omitempty"`
	Origin *string `json:"origin,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// SiteInfoWithID defines model for SiteInfoWithID.
type SiteInfoWithID struct {
	// CertId Cert ID for this site
	CertId *uint     `json:"cert_id,omitempty"`
	Id     *ObjectID `json:"id,omitempty"`
	Name   *string   `json:"name,omitempty"`
	Origin *string   `json:"origin,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// SiteListResponse defines model for SiteListResponse.
type SiteListResponse struct {
	Limit   *int              `json:"limit,omitempty"`
	List    *[]SiteInfoWithID `json:"list,omitempty"`
	PageMax *PageMax          `json:"page_max,omitempty"`
}

// TemplateInfoInput defines model for TemplateInfoInput.
type TemplateInfoInput struct {
	Content     *string   `json:"content,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Variables   *[]string `json:"variables,omitempty"`
}

// TemplateInfoWithID defines model for TemplateInfoWithID.
type TemplateInfoWithID struct {
	Content     *string   `json:"content,omitempty"`
	Description *string   `json:"description,omitempty"`
	Id          *ObjectID `json:"id,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Variables   *[]string `json:"variables,omitempty"`
}

// TemplateListResponse defines model for TemplateListResponse.
type TemplateListResponse struct {
	Limit   *int                  `json:"limit,omitempty"`
	List    *[]TemplateInfoWithID `json:"list,omitempty"`
	PageMax *PageMax              `json:"page_max,omitempty"`
}

// UserInfoCreate defines model for UserInfoCreate.
type UserInfoCreate struct {
	IsAdmin  *bool   `json:"is_admin,omitempty"`
	Name     *string `json:"name,omitempty"`
	Password string  `json:"password"`
	Username string  `json:"username"`
}

// UserInfoFull defines model for UserInfoFull.
type UserInfoFull struct {
	IsAdmin  *bool   `json:"is_admin,omitempty"`
	Name     *string `json:"name,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserInfoInput defines model for UserInfoInput.
type UserInfoInput struct {
	Name *string `json:"name,omitempty"`
}

// UserInfoWithID defines model for UserInfoWithID.
type UserInfoWithID struct {
	Id       *ObjectID `json:"id,omitempty"`
	IsAdmin  *bool     `json:"is_admin,omitempty"`
	Name     *string   `json:"name,omitempty"`
	Username *string   `json:"username,omitempty"`
}

// UserListResponse defines model for UserListResponse.
type UserListResponse struct {
	Limit   *int              `json:"limit,omitempty"`
	List    *[]UserInfoWithID `json:"list,omitempty"`
	PageMax *PageMax          `json:"page_max,omitempty"`
}

// ObjectID defines model for objectID.
type ObjectID = uint

// ObjectWithID defines model for objectWithID.
type ObjectWithID struct {
	Id *ObjectID `json:"id,omitempty"`
}

// PageMax defines model for page_max.
type PageMax = int64

// Timestamp unix second
type Timestamp = int64

// Id defines model for id.
type Id = uint

// Limit defines model for limit.
type Limit = uint

// Page defines model for page.
type Page = uint

// AdditionalFileCreateMultipartBody defines parameters for AdditionalFileCreate.
type AdditionalFileCreateMultipartBody struct {
	Content *openapi_types.File `json:"content,omitempty"`
	Name    *string             `json:"name,omitempty"`
	Path    *string             `json:"path,omitempty"`
}

// AdditionalFileListParams defines parameters for AdditionalFileList.
type AdditionalFileListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// AuthLoginJSONBody defines parameters for AuthLogin.
type AuthLoginJSONBody struct {
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// CertListParams defines parameters for CertList.
type CertListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// InstanceListParams defines parameters for InstanceList.
type InstanceListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// SiteListParams defines parameters for SiteList.
type SiteListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// TemplateListParams defines parameters for TemplateList.
type TemplateListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// UserListParams defines parameters for UserList.
type UserListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// UserPasswordUpdateJSONBody defines parameters for UserPasswordUpdate.
type UserPasswordUpdateJSONBody struct {
	Password *string `json:"password,omitempty"`
}

// UserRoleUpdateJSONBody defines parameters for UserRoleUpdate.
type UserRoleUpdateJSONBody struct {
	IsAdmin *bool `json:"is_admin,omitempty"`
}

// UserUsernameUpdateJSONBody defines parameters for UserUsernameUpdate.
type UserUsernameUpdateJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// AdditionalFileCreateMultipartRequestBody defines body for AdditionalFileCreate for multipart/form-data ContentType.
type AdditionalFileCreateMultipartRequestBody AdditionalFileCreateMultipartBody

// AdditionalFileInfoUpdateJSONRequestBody defines body for AdditionalFileInfoUpdate for application/json ContentType.
type AdditionalFileInfoUpdateJSONRequestBody = AdditionalFileInfoInput

// AuthLoginJSONRequestBody defines body for AuthLogin for application/json ContentType.
type AuthLoginJSONRequestBody AuthLoginJSONBody

// CertCreateJSONRequestBody defines body for CertCreate for application/json ContentType.
type CertCreateJSONRequestBody = CertInfoInput

// CertInfoUpdateJSONRequestBody defines body for CertInfoUpdate for application/json ContentType.
type CertInfoUpdateJSONRequestBody = CertInfoInput

// InstanceCreateJSONRequestBody defines body for InstanceCreate for application/json ContentType.
type InstanceCreateJSONRequestBody = InstanceInfoInput

// InstanceInfoUpdateJSONRequestBody defines body for InstanceInfoUpdate for application/json ContentType.
type InstanceInfoUpdateJSONRequestBody = InstanceInfoInput

// SiteCreateJSONRequestBody defines body for SiteCreate for application/json ContentType.
type SiteCreateJSONRequestBody = SiteInfoInput

// SiteInfoUpdateJSONRequestBody defines body for SiteInfoUpdate for application/json ContentType.
type SiteInfoUpdateJSONRequestBody = SiteInfoInput

// TemplateCreateJSONRequestBody defines body for TemplateCreate for application/json ContentType.
type TemplateCreateJSONRequestBody = TemplateInfoInput

// TemplateInfoUpdateJSONRequestBody defines body for TemplateInfoUpdate for application/json ContentType.
type TemplateInfoUpdateJSONRequestBody = TemplateInfoInput

// UserCreateJSONRequestBody defines body for UserCreate for application/json ContentType.
type UserCreateJSONRequestBody = UserInfoCreate

// UserInfoUpdateJSONRequestBody defines body for UserInfoUpdate for application/json ContentType.
type UserInfoUpdateJSONRequestBody = UserInfoInput

// UserPasswordUpdateJSONRequestBody defines body for UserPasswordUpdate for application/json ContentType.
type UserPasswordUpdateJSONRequestBody UserPasswordUpdateJSONBody

// UserRoleUpdateJSONRequestBody defines body for UserRoleUpdate for application/json ContentType.
type UserRoleUpdateJSONRequestBody UserRoleUpdateJSONBody

// UserUsernameUpdateJSONRequestBody defines body for UserUsernameUpdate for application/json ContentType.
type UserUsernameUpdateJSONRequestBody UserUsernameUpdateJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// create additional-file
	// (POST /additional-file/create)
	AdditionalFileCreate(ctx echo.Context) error
	// delete additional-file
	// (DELETE /additional-file/delete/{id})
	AdditionalFileDelete(ctx echo.Context, id Id) error
	// get additional-file info
	// (GET /additional-file/info/{id})
	AdditionalFileInfoGet(ctx echo.Context, id Id) error
	// update additional-file info
	// (PATCH /additional-file/info/{id})
	AdditionalFileInfoUpdate(ctx echo.Context, id Id) error
	// get additional-file list
	// (GET /additional-file/list)
	AdditionalFileList(ctx echo.Context, params AdditionalFileListParams) error
	// login
	// (POST /auth/login)
	AuthLogin(ctx echo.Context) error
	// create cert
	// (POST /cert/create)
	CertCreate(ctx echo.Context) error
	// delete cert
	// (DELETE /cert/delete/{id})
	CertDelete(ctx echo.Context, id Id) error
	// download cert pair
	// (GET /cert/download/{id})
	CertInfoDownload(ctx echo.Context, id Id) error
	// get cert info
	// (GET /cert/info/{id})
	CertInfoGet(ctx echo.Context, id Id) error
	// update cert info
	// (PATCH /cert/info/{id})
	CertInfoUpdate(ctx echo.Context, id Id) error
	// get cert list
	// (GET /cert/list)
	CertList(ctx echo.Context, params CertListParams) error
	// renew cert
	// (POST /cert/renew/{id})
	CertRenew(ctx echo.Context, id Id) error
	// health check
	// (GET /health)
	HealthCheck(ctx echo.Context) error
	// create instance
	// (POST /instance/create)
	InstanceCreate(ctx echo.Context) error
	// delete instance
	// (DELETE /instance/delete/{id})
	InstanceDelete(ctx echo.Context, id Id) error
	// get instance info
	// (GET /instance/info/{id})
	InstanceInfoGet(ctx echo.Context, id Id) error
	// update instance info
	// (PATCH /instance/info/{id})
	InstanceInfoUpdate(ctx echo.Context, id Id) error
	// get instance list
	// (GET /instance/list)
	InstanceList(ctx echo.Context, params InstanceListParams) error
	// regenerate instance token
	// (POST /instance/rotate-token/{id})
	InstanceRotateToken(ctx echo.Context, id Id) error
	// create site
	// (POST /site/create)
	SiteCreate(ctx echo.Context) error
	// delete site
	// (DELETE /site/delete/{id})
	SiteDelete(ctx echo.Context, id Id) error
	// get site info
	// (GET /site/info/{id})
	SiteInfoGet(ctx echo.Context, id Id) error
	// update site info
	// (PATCH /site/info/{id})
	SiteInfoUpdate(ctx echo.Context, id Id) error
	// get site list
	// (GET /site/list)
	SiteList(ctx echo.Context, params SiteListParams) error
	// create template
	// (POST /template/create)
	TemplateCreate(ctx echo.Context) error
	// delete template
	// (DELETE /template/delete/{id})
	TemplateDelete(ctx echo.Context, id Id) error
	// get template info
	// (GET /template/info/{id})
	TemplateInfoGet(ctx echo.Context, id Id) error
	// update template info
	// (PATCH /template/info/{id})
	TemplateInfoUpdate(ctx echo.Context, id Id) error
	// get template list
	// (GET /template/list)
	TemplateList(ctx echo.Context, params TemplateListParams) error
	// create new user
	// (POST /user/create)
	UserCreate(ctx echo.Context) error
	// delete user
	// (DELETE /user/delete/{id})
	UserDelete(ctx echo.Context, id Id) error
	// get user info
	// (GET /user/info/{id})
	UserInfoGet(ctx echo.Context, id Id) error
	// update user info
	// (PATCH /user/info/{id})
	UserInfoUpdate(ctx echo.Context, id Id) error
	// get user list
	// (GET /user/list)
	UserList(ctx echo.Context, params UserListParams) error
	// update password
	// (PUT /user/password/{id})
	UserPasswordUpdate(ctx echo.Context, id Id) error
	// update role
	// (PUT /user/role/{id})
	UserRoleUpdate(ctx echo.Context, id Id) error
	// update username
	// (PUT /user/username/{id})
	UserUsernameUpdate(ctx echo.Context, id Id) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AdditionalFileCreate converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileCreate(ctx)
	return err
}

// AdditionalFileDelete converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileDelete(ctx, id)
	return err
}

// AdditionalFileInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileInfoGet(ctx, id)
	return err
}

// AdditionalFileInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileInfoUpdate(ctx, id)
	return err
}

// AdditionalFileList converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdditionalFileListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileList(ctx, params)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AuthLogin(ctx)
	return err
}

// CertCreate converts echo context to params.
func (w *ServerInterfaceWrapper) CertCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertCreate(ctx)
	return err
}

// CertDelete converts echo context to params.
func (w *ServerInterfaceWrapper) CertDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertDelete(ctx, id)
	return err
}

// CertInfoDownload converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoDownload(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoDownload(ctx, id)
	return err
}

// CertInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoGet(ctx, id)
	return err
}

// CertInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoUpdate(ctx, id)
	return err
}

// CertList converts echo context to params.
func (w *ServerInterfaceWrapper) CertList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CertListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertList(ctx, params)
	return err
}

// CertRenew converts echo context to params.
func (w *ServerInterfaceWrapper) CertRenew(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertRenew(ctx, id)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// InstanceCreate converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceCreate(ctx)
	return err
}

// InstanceDelete converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceDelete(ctx, id)
	return err
}

// InstanceInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceInfoGet(ctx, id)
	return err
}

// InstanceInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceInfoUpdate(ctx, id)
	return err
}

// InstanceList converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params InstanceListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceList(ctx, params)
	return err
}

// InstanceRotateToken converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceRotateToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceRotateToken(ctx, id)
	return err
}

// SiteCreate converts echo context to params.
func (w *ServerInterfaceWrapper) SiteCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteCreate(ctx)
	return err
}

// SiteDelete converts echo context to params.
func (w *ServerInterfaceWrapper) SiteDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteDelete(ctx, id)
	return err
}

// SiteInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) SiteInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteInfoGet(ctx, id)
	return err
}

// SiteInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SiteInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteInfoUpdate(ctx, id)
	return err
}

// SiteList converts echo context to params.
func (w *ServerInterfaceWrapper) SiteList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SiteListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteList(ctx, params)
	return err
}

// TemplateCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateCreate(ctx)
	return err
}

// TemplateDelete converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateDelete(ctx, id)
	return err
}

// TemplateInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateInfoGet(ctx, id)
	return err
}

// TemplateInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateInfoUpdate(ctx, id)
	return err
}

// TemplateList converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TemplateListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateList(ctx, params)
	return err
}

// UserCreate converts echo context to params.
func (w *ServerInterfaceWrapper) UserCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserCreate(ctx)
	return err
}

// UserDelete converts echo context to params.
func (w *ServerInterfaceWrapper) UserDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserDelete(ctx, id)
	return err
}

// UserInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoGet(ctx, id)
	return err
}

// UserInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoUpdate(ctx, id)
	return err
}

// UserList converts echo context to params.
func (w *ServerInterfaceWrapper) UserList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserList(ctx, params)
	return err
}

// UserPasswordUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserPasswordUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserPasswordUpdate(ctx, id)
	return err
}

// UserRoleUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserRoleUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserRoleUpdate(ctx, id)
	return err
}

// UserUsernameUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserUsernameUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserUsernameUpdate(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/additional-file/create", wrapper.AdditionalFileCreate)
	router.DELETE(baseURL+"/additional-file/delete/:id", wrapper.AdditionalFileDelete)
	router.GET(baseURL+"/additional-file/info/:id", wrapper.AdditionalFileInfoGet)
	router.PATCH(baseURL+"/additional-file/info/:id", wrapper.AdditionalFileInfoUpdate)
	router.GET(baseURL+"/additional-file/list", wrapper.AdditionalFileList)
	router.POST(baseURL+"/auth/login", wrapper.AuthLogin)
	router.POST(baseURL+"/cert/create", wrapper.CertCreate)
	router.DELETE(baseURL+"/cert/delete/:id", wrapper.CertDelete)
	router.GET(baseURL+"/cert/download/:id", wrapper.CertInfoDownload)
	router.GET(baseURL+"/cert/info/:id", wrapper.CertInfoGet)
	router.PATCH(baseURL+"/cert/info/:id", wrapper.CertInfoUpdate)
	router.GET(baseURL+"/cert/list", wrapper.CertList)
	router.POST(baseURL+"/cert/renew/:id", wrapper.CertRenew)
	router.GET(baseURL+"/health", wrapper.HealthCheck)
	router.POST(baseURL+"/instance/create", wrapper.InstanceCreate)
	router.DELETE(baseURL+"/instance/delete/:id", wrapper.InstanceDelete)
	router.GET(baseURL+"/instance/info/:id", wrapper.InstanceInfoGet)
	router.PATCH(baseURL+"/instance/info/:id", wrapper.InstanceInfoUpdate)
	router.GET(baseURL+"/instance/list", wrapper.InstanceList)
	router.POST(baseURL+"/instance/rotate-token/:id", wrapper.InstanceRotateToken)
	router.POST(baseURL+"/site/create", wrapper.SiteCreate)
	router.DELETE(baseURL+"/site/delete/:id", wrapper.SiteDelete)
	router.GET(baseURL+"/site/info/:id", wrapper.SiteInfoGet)
	router.PATCH(baseURL+"/site/info/:id", wrapper.SiteInfoUpdate)
	router.GET(baseURL+"/site/list", wrapper.SiteList)
	router.POST(baseURL+"/template/create", wrapper.TemplateCreate)
	router.DELETE(baseURL+"/template/delete/:id", wrapper.TemplateDelete)
	router.GET(baseURL+"/template/info/:id", wrapper.TemplateInfoGet)
	router.PATCH(baseURL+"/template/info/:id", wrapper.TemplateInfoUpdate)
	router.GET(baseURL+"/template/list", wrapper.TemplateList)
	router.POST(baseURL+"/user/create", wrapper.UserCreate)
	router.DELETE(baseURL+"/user/delete/:id", wrapper.UserDelete)
	router.GET(baseURL+"/user/info/:id", wrapper.UserInfoGet)
	router.PATCH(baseURL+"/user/info/:id", wrapper.UserInfoUpdate)
	router.GET(baseURL+"/user/list", wrapper.UserList)
	router.PUT(baseURL+"/user/password/:id", wrapper.UserPasswordUpdate)
	router.PUT(baseURL+"/user/role/:id", wrapper.UserRoleUpdate)
	router.PUT(baseURL+"/user/username/:id", wrapper.UserUsernameUpdate)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"eZ45u9vd/wMAAP//J//IHGFpAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
