// Package admin provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package admin

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JWTAuthScopes = "JWTAuth.Scopes"
)

// AdditionalFileInfoFile defines model for AdditionalFileInfoFile.
type AdditionalFileInfoFile struct {
	Content *openapi_types.File `json:"content,omitempty"`
}

// AdditionalFileInfoInput defines model for AdditionalFileInfoInput.
type AdditionalFileInfoInput struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// AdditionalFileInfoWithID defines model for AdditionalFileInfoWithID.
type AdditionalFileInfoWithID struct {
	Id   *uint   `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// CertDownload defines model for CertDownload.
type CertDownload struct {
	Certificate             *string `json:"certificate,omitempty"`
	Csr                     *string `json:"csr,omitempty"`
	IntermediateCertificate *string `json:"intermediate_certificate,omitempty"`
	PrivateKey              *string `json:"private_key,omitempty"`
}

// CertInfoInput defines model for CertInfoInput.
type CertInfoInput struct {
	Domains  *[]string `json:"domains,omitempty"`
	Name     *string   `json:"name,omitempty"`
	Provider *string   `json:"provider,omitempty"`
}

// CertInfoWithID defines model for CertInfoWithID.
type CertInfoWithID struct {
	Domains *[]string `json:"domains,omitempty"`

	// ExpiresAt unix second
	ExpiresAt *Timestamp `json:"expires_at,omitempty"`
	Id        *uint      `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Provider  *string    `json:"provider,omitempty"`
}

// ErrorMessage defines model for ErrorMessage.
type ErrorMessage struct {
	Message *string `json:"message,omitempty"`
}

// InstanceInfoFull defines model for InstanceInfoFull.
type InstanceInfoFull struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectWithID `json:"additional_file_ids,omitempty"`

	// AdditionalFiles List of additional files
	AdditionalFiles *[]AdditionalFileInfoWithID `json:"additional_files,omitempty"`
	IsManualMode    *bool                       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectWithID `json:"site_ids,omitempty"`

	// Sites List of sites
	Sites *[]SiteInfoWithID `json:"sites,omitempty"`
}

// InstanceInfoInput defines model for InstanceInfoInput.
type InstanceInfoInput struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectWithID `json:"additional_file_ids,omitempty"`
	IsManualMode      *bool           `json:"is_manual_mode,omitempty"`
	Name              *string         `json:"name,omitempty"`
	PreConfig         *string         `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectWithID `json:"site_ids,omitempty"`
}

// InstanceInfoWithID defines model for InstanceInfoWithID.
type InstanceInfoWithID struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectWithID `json:"additional_file_ids,omitempty"`

	// AdditionalFiles List of additional files
	AdditionalFiles *[]AdditionalFileInfoWithID `json:"additional_files,omitempty"`
	Id              *uint                       `json:"id,omitempty"`
	IsManualMode    *bool                       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectWithID `json:"site_ids,omitempty"`

	// Sites List of sites
	Sites *[]SiteInfoWithID `json:"sites,omitempty"`
}

// InstanceInfoWithToken defines model for InstanceInfoWithToken.
type InstanceInfoWithToken struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectWithID `json:"additional_file_ids,omitempty"`

	// AdditionalFiles List of additional files
	AdditionalFiles *[]AdditionalFileInfoWithID `json:"additional_files,omitempty"`
	Id              *uint                       `json:"id,omitempty"`
	IsManualMode    *bool                       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectWithID `json:"site_ids,omitempty"`

	// Sites List of sites
	Sites *[]SiteInfoWithID `json:"sites,omitempty"`
	Token *string           `json:"token,omitempty"`
}

// SiteInfoFull defines model for SiteInfoFull.
type SiteInfoFull struct {
	Cert *CertInfoWithID `json:"cert,omitempty"`

	// CertId Cert ID for this site
	CertId   *uint               `json:"cert_id,omitempty"`
	Name     *string             `json:"name,omitempty"`
	Origins  *[]string           `json:"origins,omitempty"`
	Template *TemplateInfoWithID `json:"template,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// SiteInfoInput defines model for SiteInfoInput.
type SiteInfoInput struct {
	// CertId Cert ID for this site
	CertId  *uint     `json:"cert_id,omitempty"`
	Name    *string   `json:"name,omitempty"`
	Origins *[]string `json:"origins,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// SiteInfoWithID defines model for SiteInfoWithID.
type SiteInfoWithID struct {
	Cert *CertInfoWithID `json:"cert,omitempty"`

	// CertId Cert ID for this site
	CertId   *uint               `json:"cert_id,omitempty"`
	Id       *uint               `json:"id,omitempty"`
	Name     *string             `json:"name,omitempty"`
	Origins  *[]string           `json:"origins,omitempty"`
	Template *TemplateInfoWithID `json:"template,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// TemplateInfoInput defines model for TemplateInfoInput.
type TemplateInfoInput struct {
	Content     *string   `json:"content,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Variables   *[]string `json:"variables,omitempty"`
}

// TemplateInfoWithID defines model for TemplateInfoWithID.
type TemplateInfoWithID struct {
	Content     *string   `json:"content,omitempty"`
	Description *string   `json:"description,omitempty"`
	Id          *uint     `json:"id,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Variables   *[]string `json:"variables,omitempty"`
}

// UserInfoCreate defines model for UserInfoCreate.
type UserInfoCreate struct {
	IsAdmin  *bool   `json:"is_admin,omitempty"`
	Name     *string `json:"name,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserInfoFull defines model for UserInfoFull.
type UserInfoFull struct {
	IsAdmin  *bool   `json:"is_admin,omitempty"`
	Name     *string `json:"name,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserInfoInput defines model for UserInfoInput.
type UserInfoInput struct {
	Name *string `json:"name,omitempty"`
}

// UserInfoWithID defines model for UserInfoWithID.
type UserInfoWithID struct {
	Id       *ObjectWithID `json:"id,omitempty"`
	IsAdmin  *bool         `json:"is_admin,omitempty"`
	Name     *string       `json:"name,omitempty"`
	Username *string       `json:"username,omitempty"`
}

// ObjectWithID defines model for objectWithID.
type ObjectWithID struct {
	Id *uint `json:"id,omitempty"`
}

// PageMax defines model for page_max.
type PageMax = int64

// Timestamp unix second
type Timestamp = int64

// Id defines model for id.
type Id = uint

// Limit defines model for limit.
type Limit = uint

// Page defines model for page.
type Page = int64

// AdditionalFileCreateMultipartBody defines parameters for AdditionalFileCreate.
type AdditionalFileCreateMultipartBody struct {
	Content *openapi_types.File `json:"content,omitempty"`
	Name    *string             `json:"name,omitempty"`
	Path    *string             `json:"path,omitempty"`
}

// AdditionalFileListParams defines parameters for AdditionalFileList.
type AdditionalFileListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// AuthLoginJSONBody defines parameters for AuthLogin.
type AuthLoginJSONBody struct {
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// CertListParams defines parameters for CertList.
type CertListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// InstanceListParams defines parameters for InstanceList.
type InstanceListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// SiteListParams defines parameters for SiteList.
type SiteListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// TemplateListParams defines parameters for TemplateList.
type TemplateListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// UserListParams defines parameters for UserList.
type UserListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// UserPasswordUpdateJSONBody defines parameters for UserPasswordUpdate.
type UserPasswordUpdateJSONBody struct {
	Password *string `json:"password,omitempty"`
}

// UserRoleUpdateJSONBody defines parameters for UserRoleUpdate.
type UserRoleUpdateJSONBody struct {
	IsAdmin *bool `json:"is_admin,omitempty"`
}

// UserUsernameUpdateJSONBody defines parameters for UserUsernameUpdate.
type UserUsernameUpdateJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// AdditionalFileCreateMultipartRequestBody defines body for AdditionalFileCreate for multipart/form-data ContentType.
type AdditionalFileCreateMultipartRequestBody AdditionalFileCreateMultipartBody

// AdditionalFileInfoUpdateJSONRequestBody defines body for AdditionalFileInfoUpdate for application/json ContentType.
type AdditionalFileInfoUpdateJSONRequestBody = AdditionalFileInfoInput

// AuthLoginJSONRequestBody defines body for AuthLogin for application/json ContentType.
type AuthLoginJSONRequestBody AuthLoginJSONBody

// CertCreateJSONRequestBody defines body for CertCreate for application/json ContentType.
type CertCreateJSONRequestBody = CertInfoInput

// CertInfoUpdateJSONRequestBody defines body for CertInfoUpdate for application/json ContentType.
type CertInfoUpdateJSONRequestBody = CertInfoInput

// InstanceCreateJSONRequestBody defines body for InstanceCreate for application/json ContentType.
type InstanceCreateJSONRequestBody = InstanceInfoInput

// InstanceInfoUpdateJSONRequestBody defines body for InstanceInfoUpdate for application/json ContentType.
type InstanceInfoUpdateJSONRequestBody = InstanceInfoInput

// SiteCreateJSONRequestBody defines body for SiteCreate for application/json ContentType.
type SiteCreateJSONRequestBody = SiteInfoInput

// SiteInfoUpdateJSONRequestBody defines body for SiteInfoUpdate for application/json ContentType.
type SiteInfoUpdateJSONRequestBody = SiteInfoInput

// TemplateCreateJSONRequestBody defines body for TemplateCreate for application/json ContentType.
type TemplateCreateJSONRequestBody = TemplateInfoInput

// TemplateInfoUpdateJSONRequestBody defines body for TemplateInfoUpdate for application/json ContentType.
type TemplateInfoUpdateJSONRequestBody = TemplateInfoInput

// UserCreateJSONRequestBody defines body for UserCreate for application/json ContentType.
type UserCreateJSONRequestBody = UserInfoCreate

// UserInfoUpdateJSONRequestBody defines body for UserInfoUpdate for application/json ContentType.
type UserInfoUpdateJSONRequestBody = UserInfoInput

// UserPasswordUpdateJSONRequestBody defines body for UserPasswordUpdate for application/json ContentType.
type UserPasswordUpdateJSONRequestBody UserPasswordUpdateJSONBody

// UserRoleUpdateJSONRequestBody defines body for UserRoleUpdate for application/json ContentType.
type UserRoleUpdateJSONRequestBody UserRoleUpdateJSONBody

// UserUsernameUpdateJSONRequestBody defines body for UserUsernameUpdate for application/json ContentType.
type UserUsernameUpdateJSONRequestBody UserUsernameUpdateJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// create additional-file
	// (POST /additional-file/create)
	AdditionalFileCreate(ctx echo.Context) error
	// delete additional-file
	// (DELETE /additional-file/delete/{id})
	AdditionalFileDelete(ctx echo.Context, id Id) error
	// get additional-file info
	// (GET /additional-file/info/{id})
	AdditionalFileInfoGet(ctx echo.Context, id Id) error
	// update additional-file info
	// (PATCH /additional-file/info/{id})
	AdditionalFileInfoUpdate(ctx echo.Context, id Id) error
	// get additional-file list
	// (GET /additional-file/list)
	AdditionalFileList(ctx echo.Context, params AdditionalFileListParams) error
	// login
	// (POST /auth/login)
	AuthLogin(ctx echo.Context) error
	// create cert
	// (POST /cert/create)
	CertCreate(ctx echo.Context) error
	// delete cert
	// (DELETE /cert/delete/{id})
	CertDelete(ctx echo.Context, id Id) error
	// download cert pair
	// (GET /cert/download/{id})
	CertInfoGet(ctx echo.Context, id Id) error
	// get cert info
	// (GET /cert/info/{id})
	CertInfoGet(ctx echo.Context, id Id) error
	// update cert info
	// (PATCH /cert/info/{id})
	CertInfoUpdate(ctx echo.Context, id Id) error
	// get cert list
	// (GET /cert/list)
	CertList(ctx echo.Context, params CertListParams) error
	// renew cert
	// (POST /cert/renew/{id})
	CertRenew(ctx echo.Context, id Id) error
	// health check
	// (GET /health)
	HealthCheck(ctx echo.Context) error
	// create instance
	// (POST /instance/create)
	InstanceCreate(ctx echo.Context) error
	// delete instance
	// (DELETE /instance/delete/{id})
	InstanceDelete(ctx echo.Context, id Id) error
	// get instance info
	// (GET /instance/info/{id})
	InstanceInfoGet(ctx echo.Context, id Id) error
	// update instance info
	// (PATCH /instance/info/{id})
	InstanceInfoUpdate(ctx echo.Context, id Id) error
	// get instance list
	// (GET /instance/list)
	InstanceList(ctx echo.Context, params InstanceListParams) error
	// regenerate
	// (POST /instance/rotate-token/{id})
	InstanceRotateToken(ctx echo.Context, id Id) error
	// create site
	// (POST /site/create)
	SiteCreate(ctx echo.Context) error
	// delete site
	// (DELETE /site/delete/{id})
	SiteDelete(ctx echo.Context, id Id) error
	// get site info
	// (GET /site/info/{id})
	SiteInfoGet(ctx echo.Context, id Id) error
	// update site info
	// (PATCH /site/info/{id})
	SiteInfoUpdate(ctx echo.Context, id Id) error
	// get site list
	// (GET /site/list)
	SiteList(ctx echo.Context, params SiteListParams) error
	// create template
	// (POST /template/create)
	TemplateCreate(ctx echo.Context) error
	// delete template
	// (DELETE /template/delete/{id})
	TemplateDelete(ctx echo.Context, id Id) error
	// get template info
	// (GET /template/info/{id})
	TemplateInfoGet(ctx echo.Context, id Id) error
	// update template info
	// (PATCH /template/info/{id})
	TemplateInfoUpdate(ctx echo.Context, id Id) error
	// get template list
	// (GET /template/list)
	TemplateList(ctx echo.Context, params TemplateListParams) error
	// create new user
	// (POST /user/create)
	UserCreate(ctx echo.Context) error
	// delete user
	// (DELETE /user/delete/{id})
	UserDelete(ctx echo.Context, id Id) error
	// get user info
	// (GET /user/info/{id})
	UserInfoGet(ctx echo.Context, id Id) error
	// update user info
	// (PATCH /user/info/{id})
	UserInfoUpdate(ctx echo.Context, id Id) error
	// get user list
	// (GET /user/list)
	UserList(ctx echo.Context, params UserListParams) error
	// update password
	// (PUT /user/password/{id})
	UserPasswordUpdate(ctx echo.Context, id Id) error
	// update role
	// (PUT /user/role/{id})
	UserRoleUpdate(ctx echo.Context, id Id) error
	// update username
	// (PUT /user/username/{id})
	UserUsernameUpdate(ctx echo.Context, id Id) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AdditionalFileCreate converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileCreate(ctx)
	return err
}

// AdditionalFileDelete converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileDelete(ctx, id)
	return err
}

// AdditionalFileInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileInfoGet(ctx, id)
	return err
}

// AdditionalFileInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileInfoUpdate(ctx, id)
	return err
}

// AdditionalFileList converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdditionalFileListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileList(ctx, params)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AuthLogin(ctx)
	return err
}

// CertCreate converts echo context to params.
func (w *ServerInterfaceWrapper) CertCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertCreate(ctx)
	return err
}

// CertDelete converts echo context to params.
func (w *ServerInterfaceWrapper) CertDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertDelete(ctx, id)
	return err
}

// CertInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoGet(ctx, id)
	return err
}

// CertInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoGet(ctx, id)
	return err
}

// CertInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoUpdate(ctx, id)
	return err
}

// CertList converts echo context to params.
func (w *ServerInterfaceWrapper) CertList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CertListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertList(ctx, params)
	return err
}

// CertRenew converts echo context to params.
func (w *ServerInterfaceWrapper) CertRenew(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertRenew(ctx, id)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// InstanceCreate converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceCreate(ctx)
	return err
}

// InstanceDelete converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceDelete(ctx, id)
	return err
}

// InstanceInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceInfoGet(ctx, id)
	return err
}

// InstanceInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceInfoUpdate(ctx, id)
	return err
}

// InstanceList converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params InstanceListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceList(ctx, params)
	return err
}

// InstanceRotateToken converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceRotateToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceRotateToken(ctx, id)
	return err
}

// SiteCreate converts echo context to params.
func (w *ServerInterfaceWrapper) SiteCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteCreate(ctx)
	return err
}

// SiteDelete converts echo context to params.
func (w *ServerInterfaceWrapper) SiteDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteDelete(ctx, id)
	return err
}

// SiteInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) SiteInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteInfoGet(ctx, id)
	return err
}

// SiteInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SiteInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteInfoUpdate(ctx, id)
	return err
}

// SiteList converts echo context to params.
func (w *ServerInterfaceWrapper) SiteList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params SiteListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteList(ctx, params)
	return err
}

// TemplateCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateCreate(ctx)
	return err
}

// TemplateDelete converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateDelete(ctx, id)
	return err
}

// TemplateInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateInfoGet(ctx, id)
	return err
}

// TemplateInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateInfoUpdate(ctx, id)
	return err
}

// TemplateList converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params TemplateListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateList(ctx, params)
	return err
}

// UserCreate converts echo context to params.
func (w *ServerInterfaceWrapper) UserCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserCreate(ctx)
	return err
}

// UserDelete converts echo context to params.
func (w *ServerInterfaceWrapper) UserDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserDelete(ctx, id)
	return err
}

// UserInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoGet(ctx, id)
	return err
}

// UserInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoUpdate(ctx, id)
	return err
}

// UserList converts echo context to params.
func (w *ServerInterfaceWrapper) UserList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserList(ctx, params)
	return err
}

// UserPasswordUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserPasswordUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserPasswordUpdate(ctx, id)
	return err
}

// UserRoleUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserRoleUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserRoleUpdate(ctx, id)
	return err
}

// UserUsernameUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserUsernameUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserUsernameUpdate(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/additional-file/create", wrapper.AdditionalFileCreate)
	router.DELETE(baseURL+"/additional-file/delete/:id", wrapper.AdditionalFileDelete)
	router.GET(baseURL+"/additional-file/info/:id", wrapper.AdditionalFileInfoGet)
	router.PATCH(baseURL+"/additional-file/info/:id", wrapper.AdditionalFileInfoUpdate)
	router.GET(baseURL+"/additional-file/list", wrapper.AdditionalFileList)
	router.POST(baseURL+"/auth/login", wrapper.AuthLogin)
	router.POST(baseURL+"/cert/create", wrapper.CertCreate)
	router.DELETE(baseURL+"/cert/delete/:id", wrapper.CertDelete)
	router.GET(baseURL+"/cert/download/:id", wrapper.CertInfoGet)
	router.GET(baseURL+"/cert/info/:id", wrapper.CertInfoGet)
	router.PATCH(baseURL+"/cert/info/:id", wrapper.CertInfoUpdate)
	router.GET(baseURL+"/cert/list", wrapper.CertList)
	router.POST(baseURL+"/cert/renew/:id", wrapper.CertRenew)
	router.GET(baseURL+"/health", wrapper.HealthCheck)
	router.POST(baseURL+"/instance/create", wrapper.InstanceCreate)
	router.DELETE(baseURL+"/instance/delete/:id", wrapper.InstanceDelete)
	router.GET(baseURL+"/instance/info/:id", wrapper.InstanceInfoGet)
	router.PATCH(baseURL+"/instance/info/:id", wrapper.InstanceInfoUpdate)
	router.GET(baseURL+"/instance/list", wrapper.InstanceList)
	router.POST(baseURL+"/instance/rotate-token/:id", wrapper.InstanceRotateToken)
	router.POST(baseURL+"/site/create", wrapper.SiteCreate)
	router.DELETE(baseURL+"/site/delete/:id", wrapper.SiteDelete)
	router.GET(baseURL+"/site/info/:id", wrapper.SiteInfoGet)
	router.PATCH(baseURL+"/site/info/:id", wrapper.SiteInfoUpdate)
	router.GET(baseURL+"/site/list", wrapper.SiteList)
	router.POST(baseURL+"/template/create", wrapper.TemplateCreate)
	router.DELETE(baseURL+"/template/delete/:id", wrapper.TemplateDelete)
	router.GET(baseURL+"/template/info/:id", wrapper.TemplateInfoGet)
	router.PATCH(baseURL+"/template/info/:id", wrapper.TemplateInfoUpdate)
	router.GET(baseURL+"/template/list", wrapper.TemplateList)
	router.POST(baseURL+"/user/create", wrapper.UserCreate)
	router.DELETE(baseURL+"/user/delete/:id", wrapper.UserDelete)
	router.GET(baseURL+"/user/info/:id", wrapper.UserInfoGet)
	router.PATCH(baseURL+"/user/info/:id", wrapper.UserInfoUpdate)
	router.GET(baseURL+"/user/list", wrapper.UserList)
	router.PUT(baseURL+"/user/password/:id", wrapper.UserPasswordUpdate)
	router.PUT(baseURL+"/user/role/:id", wrapper.UserRoleUpdate)
	router.PUT(baseURL+"/user/username/:id", wrapper.UserUsernameUpdate)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"ZjJne7/9fwAAAP//cgcPzFBoAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
