// Package admin provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package admin

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JWTAuthScopes = "JWTAuth.Scopes"
)

// AdditionalFileInfoFile defines model for AdditionalFileInfoFile.
type AdditionalFileInfoFile struct {
	Content *openapi_types.File `json:"content,omitempty"`
}

// AdditionalFileInfoInput defines model for AdditionalFileInfoInput.
type AdditionalFileInfoInput struct {
	Name *string `json:"name,omitempty"`
	Path *string `json:"path,omitempty"`
}

// AdditionalFileInfoWithID defines model for AdditionalFileInfoWithID.
type AdditionalFileInfoWithID struct {
	Id   *ObjectID `json:"id,omitempty"`
	Name *string   `json:"name,omitempty"`
	Path *string   `json:"path,omitempty"`
}

// CertDownload defines model for CertDownload.
type CertDownload struct {
	Certificate             *string `json:"certificate,omitempty"`
	Csr                     *string `json:"csr,omitempty"`
	IntermediateCertificate *string `json:"intermediate_certificate,omitempty"`
	PrivateKey              *string `json:"private_key,omitempty"`
}

// CertInfoInput defines model for CertInfoInput.
type CertInfoInput struct {
	Domains  *[]string `json:"domains,omitempty"`
	Name     *string   `json:"name,omitempty"`
	Provider *string   `json:"provider,omitempty"`
}

// CertInfoWithID defines model for CertInfoWithID.
type CertInfoWithID struct {
	Domains *[]string `json:"domains,omitempty"`

	// ExpiresAt unix second
	ExpiresAt *Timestamp `json:"expires_at,omitempty"`
	Id        *ObjectID  `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Provider  *string    `json:"provider,omitempty"`
}

// ErrorMessage defines model for ErrorMessage.
type ErrorMessage struct {
	Message *string `json:"message,omitempty"`
}

// InstanceInfoFull defines model for InstanceInfoFull.
type InstanceInfoFull struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
}

// InstanceInfoInput defines model for InstanceInfoInput.
type InstanceInfoInput struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`
	Name              *string     `json:"name,omitempty"`
	PreConfig         *string     `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
}

// InstanceInfoWithID defines model for InstanceInfoWithID.
type InstanceInfoWithID struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	Id                *ObjectID   `json:"id,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
}

// InstanceInfoWithToken defines model for InstanceInfoWithToken.
type InstanceInfoWithToken struct {
	// AdditionalFileIds ID list of additional files
	AdditionalFileIds *[]ObjectID `json:"additional_file_ids,omitempty"`
	Id                *ObjectID   `json:"id,omitempty"`
	IsManualMode      *bool       `json:"is_manual_mode,omitempty"`

	// LastSeen unix second
	LastSeen  *Timestamp `json:"last_seen,omitempty"`
	Name      *string    `json:"name,omitempty"`
	PreConfig *string    `json:"pre_config,omitempty"`

	// SiteIds ID list of sites
	SiteIds *[]ObjectID `json:"site_ids,omitempty"`
	Token   *string     `json:"token,omitempty"`
}

// InstanceListResponse defines model for InstanceListResponse.
type InstanceListResponse struct {
	Limit   *int                  `json:"limit,omitempty"`
	List    *[]InstanceInfoWithID `json:"list,omitempty"`
	PageMax *PageMax              `json:"page_max,omitempty"`
}

// LoginToken defines model for LoginToken.
type LoginToken struct {
	// Token JWT Token
	Token *string `json:"token,omitempty"`
}

// SiteInfoFull defines model for SiteInfoFull.
type SiteInfoFull struct {
	Cert *CertInfoWithID `json:"cert,omitempty"`

	// CertId Cert ID for this site
	CertId   *uint               `json:"cert_id,omitempty"`
	Name     *string             `json:"name,omitempty"`
	Origins  *[]string           `json:"origins,omitempty"`
	Template *TemplateInfoWithID `json:"template,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// SiteInfoInput defines model for SiteInfoInput.
type SiteInfoInput struct {
	// CertId Cert ID for this site
	CertId  *uint     `json:"cert_id,omitempty"`
	Name    *string   `json:"name,omitempty"`
	Origins *[]string `json:"origins,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// SiteInfoWithID defines model for SiteInfoWithID.
type SiteInfoWithID struct {
	Cert *CertInfoWithID `json:"cert,omitempty"`

	// CertId Cert ID for this site
	CertId   *uint               `json:"cert_id,omitempty"`
	Id       *ObjectID           `json:"id,omitempty"`
	Name     *string             `json:"name,omitempty"`
	Origins  *[]string           `json:"origins,omitempty"`
	Template *TemplateInfoWithID `json:"template,omitempty"`

	// TemplateId Template ID for this site
	TemplateId     *uint     `json:"template_id,omitempty"`
	TemplateValues *[]string `json:"template_values,omitempty"`
}

// TemplateInfoInput defines model for TemplateInfoInput.
type TemplateInfoInput struct {
	Content     *string   `json:"content,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Variables   *[]string `json:"variables,omitempty"`
}

// TemplateInfoWithID defines model for TemplateInfoWithID.
type TemplateInfoWithID struct {
	Content     *string   `json:"content,omitempty"`
	Description *string   `json:"description,omitempty"`
	Id          *ObjectID `json:"id,omitempty"`
	Name        *string   `json:"name,omitempty"`
	Variables   *[]string `json:"variables,omitempty"`
}

// UserInfoCreate defines model for UserInfoCreate.
type UserInfoCreate struct {
	IsAdmin  *bool   `json:"is_admin,omitempty"`
	Name     *string `json:"name,omitempty"`
	Password string  `json:"password"`
	Username string  `json:"username"`
}

// UserInfoFull defines model for UserInfoFull.
type UserInfoFull struct {
	IsAdmin  *bool   `json:"is_admin,omitempty"`
	Name     *string `json:"name,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UserInfoInput defines model for UserInfoInput.
type UserInfoInput struct {
	Name *string `json:"name,omitempty"`
}

// UserInfoWithID defines model for UserInfoWithID.
type UserInfoWithID struct {
	Id       *ObjectID `json:"id,omitempty"`
	IsAdmin  *bool     `json:"is_admin,omitempty"`
	Name     *string   `json:"name,omitempty"`
	Username *string   `json:"username,omitempty"`
}

// UserListResponse defines model for UserListResponse.
type UserListResponse struct {
	Limit   *int              `json:"limit,omitempty"`
	List    *[]UserInfoWithID `json:"list,omitempty"`
	PageMax *PageMax          `json:"page_max,omitempty"`
}

// ObjectID defines model for objectID.
type ObjectID = uint

// ObjectWithID defines model for objectWithID.
type ObjectWithID struct {
	Id *ObjectID `json:"id,omitempty"`
}

// PageMax defines model for page_max.
type PageMax = int64

// Timestamp unix second
type Timestamp = int64

// Id defines model for id.
type Id = uint

// Limit defines model for limit.
type Limit = uint

// Page defines model for page.
type Page = uint

// AdditionalFileCreateMultipartBody defines parameters for AdditionalFileCreate.
type AdditionalFileCreateMultipartBody struct {
	Content *openapi_types.File `json:"content,omitempty"`
	Name    *string             `json:"name,omitempty"`
	Path    *string             `json:"path,omitempty"`
}

// AdditionalFileListParams defines parameters for AdditionalFileList.
type AdditionalFileListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// AuthLoginJSONBody defines parameters for AuthLogin.
type AuthLoginJSONBody struct {
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// CertListParams defines parameters for CertList.
type CertListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// InstanceListParams defines parameters for InstanceList.
type InstanceListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// SiteListParams defines parameters for SiteList.
type SiteListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// TemplateListParams defines parameters for TemplateList.
type TemplateListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// UserListParams defines parameters for UserList.
type UserListParams struct {
	// Page The page number
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Limit Limit the number of items per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// UserPasswordUpdateJSONBody defines parameters for UserPasswordUpdate.
type UserPasswordUpdateJSONBody struct {
	Password *string `json:"password,omitempty"`
}

// UserRoleUpdateJSONBody defines parameters for UserRoleUpdate.
type UserRoleUpdateJSONBody struct {
	IsAdmin *bool `json:"is_admin,omitempty"`
}

// UserUsernameUpdateJSONBody defines parameters for UserUsernameUpdate.
type UserUsernameUpdateJSONBody struct {
	Username *string `json:"username,omitempty"`
}

// AdditionalFileCreateMultipartRequestBody defines body for AdditionalFileCreate for multipart/form-data ContentType.
type AdditionalFileCreateMultipartRequestBody AdditionalFileCreateMultipartBody

// AdditionalFileInfoUpdateJSONRequestBody defines body for AdditionalFileInfoUpdate for application/json ContentType.
type AdditionalFileInfoUpdateJSONRequestBody = AdditionalFileInfoInput

// AuthLoginJSONRequestBody defines body for AuthLogin for application/json ContentType.
type AuthLoginJSONRequestBody AuthLoginJSONBody

// CertCreateJSONRequestBody defines body for CertCreate for application/json ContentType.
type CertCreateJSONRequestBody = CertInfoInput

// CertInfoUpdateJSONRequestBody defines body for CertInfoUpdate for application/json ContentType.
type CertInfoUpdateJSONRequestBody = CertInfoInput

// InstanceCreateJSONRequestBody defines body for InstanceCreate for application/json ContentType.
type InstanceCreateJSONRequestBody = InstanceInfoInput

// InstanceInfoUpdateJSONRequestBody defines body for InstanceInfoUpdate for application/json ContentType.
type InstanceInfoUpdateJSONRequestBody = InstanceInfoInput

// SiteCreateJSONRequestBody defines body for SiteCreate for application/json ContentType.
type SiteCreateJSONRequestBody = SiteInfoInput

// SiteInfoUpdateJSONRequestBody defines body for SiteInfoUpdate for application/json ContentType.
type SiteInfoUpdateJSONRequestBody = SiteInfoInput

// TemplateCreateJSONRequestBody defines body for TemplateCreate for application/json ContentType.
type TemplateCreateJSONRequestBody = TemplateInfoInput

// TemplateInfoUpdateJSONRequestBody defines body for TemplateInfoUpdate for application/json ContentType.
type TemplateInfoUpdateJSONRequestBody = TemplateInfoInput

// UserCreateJSONRequestBody defines body for UserCreate for application/json ContentType.
type UserCreateJSONRequestBody = UserInfoCreate

// UserInfoUpdateJSONRequestBody defines body for UserInfoUpdate for application/json ContentType.
type UserInfoUpdateJSONRequestBody = UserInfoInput

// UserPasswordUpdateJSONRequestBody defines body for UserPasswordUpdate for application/json ContentType.
type UserPasswordUpdateJSONRequestBody UserPasswordUpdateJSONBody

// UserRoleUpdateJSONRequestBody defines body for UserRoleUpdate for application/json ContentType.
type UserRoleUpdateJSONRequestBody UserRoleUpdateJSONBody

// UserUsernameUpdateJSONRequestBody defines body for UserUsernameUpdate for application/json ContentType.
type UserUsernameUpdateJSONRequestBody UserUsernameUpdateJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// create additional-file
	// (POST /additional-file/create)
	AdditionalFileCreate(ctx echo.Context) error
	// delete additional-file
	// (DELETE /additional-file/delete/{id})
	AdditionalFileDelete(ctx echo.Context, id Id) error
	// get additional-file info
	// (GET /additional-file/info/{id})
	AdditionalFileInfoGet(ctx echo.Context, id Id) error
	// update additional-file info
	// (PATCH /additional-file/info/{id})
	AdditionalFileInfoUpdate(ctx echo.Context, id Id) error
	// get additional-file list
	// (GET /additional-file/list)
	AdditionalFileList(ctx echo.Context, params AdditionalFileListParams) error
	// login
	// (POST /auth/login)
	AuthLogin(ctx echo.Context) error
	// create cert
	// (POST /cert/create)
	CertCreate(ctx echo.Context) error
	// delete cert
	// (DELETE /cert/delete/{id})
	CertDelete(ctx echo.Context, id Id) error
	// download cert pair
	// (GET /cert/download/{id})
	CertInfoDownload(ctx echo.Context, id Id) error
	// get cert info
	// (GET /cert/info/{id})
	CertInfoGet(ctx echo.Context, id Id) error
	// update cert info
	// (PATCH /cert/info/{id})
	CertInfoUpdate(ctx echo.Context, id Id) error
	// get cert list
	// (GET /cert/list)
	CertList(ctx echo.Context, params CertListParams) error
	// renew cert
	// (POST /cert/renew/{id})
	CertRenew(ctx echo.Context, id Id) error
	// health check
	// (GET /health)
	HealthCheck(ctx echo.Context) error
	// create instance
	// (POST /instance/create)
	InstanceCreate(ctx echo.Context) error
	// delete instance
	// (DELETE /instance/delete/{id})
	InstanceDelete(ctx echo.Context, id Id) error
	// get instance info
	// (GET /instance/info/{id})
	InstanceInfoGet(ctx echo.Context, id Id) error
	// update instance info
	// (PATCH /instance/info/{id})
	InstanceInfoUpdate(ctx echo.Context, id Id) error
	// get instance list
	// (GET /instance/list)
	InstanceList(ctx echo.Context, params InstanceListParams) error
	// regenerate instance token
	// (POST /instance/rotate-token/{id})
	InstanceRotateToken(ctx echo.Context, id Id) error
	// create site
	// (POST /site/create)
	SiteCreate(ctx echo.Context) error
	// delete site
	// (DELETE /site/delete/{id})
	SiteDelete(ctx echo.Context, id Id) error
	// get site info
	// (GET /site/info/{id})
	SiteInfoGet(ctx echo.Context, id Id) error
	// update site info
	// (PATCH /site/info/{id})
	SiteInfoUpdate(ctx echo.Context, id Id) error
	// get site list
	// (GET /site/list)
	SiteList(ctx echo.Context, params SiteListParams) error
	// create template
	// (POST /template/create)
	TemplateCreate(ctx echo.Context) error
	// delete template
	// (DELETE /template/delete/{id})
	TemplateDelete(ctx echo.Context, id Id) error
	// get template info
	// (GET /template/info/{id})
	TemplateInfoGet(ctx echo.Context, id Id) error
	// update template info
	// (PATCH /template/info/{id})
	TemplateInfoUpdate(ctx echo.Context, id Id) error
	// get template list
	// (GET /template/list)
	TemplateList(ctx echo.Context, params TemplateListParams) error
	// create new user
	// (POST /user/create)
	UserCreate(ctx echo.Context) error
	// delete user
	// (DELETE /user/delete/{id})
	UserDelete(ctx echo.Context, id Id) error
	// get user info
	// (GET /user/info/{id})
	UserInfoGet(ctx echo.Context, id Id) error
	// update user info
	// (PATCH /user/info/{id})
	UserInfoUpdate(ctx echo.Context, id Id) error
	// get user list
	// (GET /user/list)
	UserList(ctx echo.Context, params UserListParams) error
	// update password
	// (PUT /user/password/{id})
	UserPasswordUpdate(ctx echo.Context, id Id) error
	// update role
	// (PUT /user/role/{id})
	UserRoleUpdate(ctx echo.Context, id Id) error
	// update username
	// (PUT /user/username/{id})
	UserUsernameUpdate(ctx echo.Context, id Id) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AdditionalFileCreate converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileCreate(ctx)
	return err
}

// AdditionalFileDelete converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileDelete(ctx, id)
	return err
}

// AdditionalFileInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileInfoGet(ctx, id)
	return err
}

// AdditionalFileInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileInfoUpdate(ctx, id)
	return err
}

// AdditionalFileList converts echo context to params.
func (w *ServerInterfaceWrapper) AdditionalFileList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AdditionalFileListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AdditionalFileList(ctx, params)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AuthLogin(ctx)
	return err
}

// CertCreate converts echo context to params.
func (w *ServerInterfaceWrapper) CertCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertCreate(ctx)
	return err
}

// CertDelete converts echo context to params.
func (w *ServerInterfaceWrapper) CertDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertDelete(ctx, id)
	return err
}

// CertInfoDownload converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoDownload(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoDownload(ctx, id)
	return err
}

// CertInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoGet(ctx, id)
	return err
}

// CertInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) CertInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertInfoUpdate(ctx, id)
	return err
}

// CertList converts echo context to params.
func (w *ServerInterfaceWrapper) CertList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CertListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertList(ctx, params)
	return err
}

// CertRenew converts echo context to params.
func (w *ServerInterfaceWrapper) CertRenew(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CertRenew(ctx, id)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// InstanceCreate converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceCreate(ctx)
	return err
}

// InstanceDelete converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceDelete(ctx, id)
	return err
}

// InstanceInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceInfoGet(ctx, id)
	return err
}

// InstanceInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceInfoUpdate(ctx, id)
	return err
}

// InstanceList converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params InstanceListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceList(ctx, params)
	return err
}

// InstanceRotateToken converts echo context to params.
func (w *ServerInterfaceWrapper) InstanceRotateToken(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.InstanceRotateToken(ctx, id)
	return err
}

// SiteCreate converts echo context to params.
func (w *ServerInterfaceWrapper) SiteCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteCreate(ctx)
	return err
}

// SiteDelete converts echo context to params.
func (w *ServerInterfaceWrapper) SiteDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteDelete(ctx, id)
	return err
}

// SiteInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) SiteInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteInfoGet(ctx, id)
	return err
}

// SiteInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) SiteInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteInfoUpdate(ctx, id)
	return err
}

// SiteList converts echo context to params.
func (w *ServerInterfaceWrapper) SiteList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SiteListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SiteList(ctx, params)
	return err
}

// TemplateCreate converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateCreate(ctx)
	return err
}

// TemplateDelete converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateDelete(ctx, id)
	return err
}

// TemplateInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateInfoGet(ctx, id)
	return err
}

// TemplateInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateInfoUpdate(ctx, id)
	return err
}

// TemplateList converts echo context to params.
func (w *ServerInterfaceWrapper) TemplateList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TemplateListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TemplateList(ctx, params)
	return err
}

// UserCreate converts echo context to params.
func (w *ServerInterfaceWrapper) UserCreate(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserCreate(ctx)
	return err
}

// UserDelete converts echo context to params.
func (w *ServerInterfaceWrapper) UserDelete(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserDelete(ctx, id)
	return err
}

// UserInfoGet converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoGet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoGet(ctx, id)
	return err
}

// UserInfoUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserInfoUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserInfoUpdate(ctx, id)
	return err
}

// UserList converts echo context to params.
func (w *ServerInterfaceWrapper) UserList(ctx echo.Context) error {
	var err error

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UserListParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserList(ctx, params)
	return err
}

// UserPasswordUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserPasswordUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserPasswordUpdate(ctx, id)
	return err
}

// UserRoleUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserRoleUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{"admin"})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserRoleUpdate(ctx, id)
	return err
}

// UserUsernameUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) UserUsernameUpdate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id Id

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(JWTAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UserUsernameUpdate(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/additional-file/create", wrapper.AdditionalFileCreate)
	router.DELETE(baseURL+"/additional-file/delete/:id", wrapper.AdditionalFileDelete)
	router.GET(baseURL+"/additional-file/info/:id", wrapper.AdditionalFileInfoGet)
	router.PATCH(baseURL+"/additional-file/info/:id", wrapper.AdditionalFileInfoUpdate)
	router.GET(baseURL+"/additional-file/list", wrapper.AdditionalFileList)
	router.POST(baseURL+"/auth/login", wrapper.AuthLogin)
	router.POST(baseURL+"/cert/create", wrapper.CertCreate)
	router.DELETE(baseURL+"/cert/delete/:id", wrapper.CertDelete)
	router.GET(baseURL+"/cert/download/:id", wrapper.CertInfoDownload)
	router.GET(baseURL+"/cert/info/:id", wrapper.CertInfoGet)
	router.PATCH(baseURL+"/cert/info/:id", wrapper.CertInfoUpdate)
	router.GET(baseURL+"/cert/list", wrapper.CertList)
	router.POST(baseURL+"/cert/renew/:id", wrapper.CertRenew)
	router.GET(baseURL+"/health", wrapper.HealthCheck)
	router.POST(baseURL+"/instance/create", wrapper.InstanceCreate)
	router.DELETE(baseURL+"/instance/delete/:id", wrapper.InstanceDelete)
	router.GET(baseURL+"/instance/info/:id", wrapper.InstanceInfoGet)
	router.PATCH(baseURL+"/instance/info/:id", wrapper.InstanceInfoUpdate)
	router.GET(baseURL+"/instance/list", wrapper.InstanceList)
	router.POST(baseURL+"/instance/rotate-token/:id", wrapper.InstanceRotateToken)
	router.POST(baseURL+"/site/create", wrapper.SiteCreate)
	router.DELETE(baseURL+"/site/delete/:id", wrapper.SiteDelete)
	router.GET(baseURL+"/site/info/:id", wrapper.SiteInfoGet)
	router.PATCH(baseURL+"/site/info/:id", wrapper.SiteInfoUpdate)
	router.GET(baseURL+"/site/list", wrapper.SiteList)
	router.POST(baseURL+"/template/create", wrapper.TemplateCreate)
	router.DELETE(baseURL+"/template/delete/:id", wrapper.TemplateDelete)
	router.GET(baseURL+"/template/info/:id", wrapper.TemplateInfoGet)
	router.PATCH(baseURL+"/template/info/:id", wrapper.TemplateInfoUpdate)
	router.GET(baseURL+"/template/list", wrapper.TemplateList)
	router.POST(baseURL+"/user/create", wrapper.UserCreate)
	router.DELETE(baseURL+"/user/delete/:id", wrapper.UserDelete)
	router.GET(baseURL+"/user/info/:id", wrapper.UserInfoGet)
	router.PATCH(baseURL+"/user/info/:id", wrapper.UserInfoUpdate)
	router.GET(baseURL+"/user/list", wrapper.UserList)
	router.PUT(baseURL+"/user/password/:id", wrapper.UserPasswordUpdate)
	router.PUT(baseURL+"/user/role/:id", wrapper.UserRoleUpdate)
	router.PUT(baseURL+"/user/username/:id", wrapper.UserUsernameUpdate)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"2/vt/wMAAP//LZnRp71oAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
